//Chapter03 String, Vectors and Arrays

//3.1 Namespace using Declarations

//A using declaration lets us use a name from a namespace without qualifying the name with a namespace_name:: prefix. A using declaration has the form
using namespace::name;

//Headers Should Not Include using Declarations
//Code inside headers ordinarily should not use using declarations. The reason is that the contents of a header are copied into the including program’s text. If a header has a using declaration, then every program that includes that header gets that same using declaration. As a result, a program that didn’t intend to use the specified library name might encounter unexpected name conflicts.

//3.2 Library string type

//A string is a variable-length sequence of characters. To use the string type, we must include the string header. Because it is part of the library, string is defined in the std namespace. Our examples assume the following code:
#include <string>
using std::string;

//3.2.1 Defining and Initializing strings

//Ways to initialize a string
string s1;       //Default initializing; s1 is the empty string
string s2(s1);   //s2 is a copy of s1
string s2=s1;    //Equivalent to s2(s1), s2 is a copy of s1
string s3("value");    //s3 is a copy of the string literal, not including the null
string s3="value";     //Equivalent to s3("value"), s3 is a copy of the string literal
string s4(n, 'c');     //Initalize s4 with n copies of the character 'c'

//When we initialize a variable using =, we are asking the compiler to copy initialize the object by copying the initializer on the right-hand side into the object being created. Otherwise, when we omit the =, we use direct initialization.

//3.2.2 Operations on strings
os<<s;    //writes s onto output stream os, returns os
is>>s;    //reads whitespace-separated string from is into s, returns is
getline(is, s);    //reads a line of input from 'is' into s. Return 'is'
s.empty();    //returns true if s is empty
s.size();    //returns the number of characters in s
s[n];    //return a reference to the char at position n in s; positions start at 0
s1+s2;    //returns a string that is the concatenation of s1 and s2
s1=s2;    //replaces characters in s1 with a copy of s2
s1==s2;    //the strings s1 and s2 are equal if they contain the same characters
s1!=s2;
<, <=, >, >=    //comparison are case-sensitive and u se dictionary ordering

//Sometimes we do no want to ignore the whitespace in out input. In such cases, we can use the getline function instead of the >> operator.
//The getline function takes an input stream and a string. This function reads the given stream up to and including the first newline and stores what it reads - not including the newline - in its string argument.

//string::size_type Type
//size returns a string::size_type value.
//The string class—and most other library types—defines several companion types. These companion types make it possible to use the library types in a machineindependent manner. The type size_type is one of these companion types. To use the size_type defined by string, we use the scope operator to say that the name size_type is defined in the string class.
//Although we don’t know the precise type of string::size_type, we do know that it is an unsigned type big enough to hold the size of any string. Any variable used to store the result from the string size operation should be of type string::size_type.

//Admittedly, it can be tedious to type string::size_type. Under the new standard, we can ask the compiler to provide the appropriate type by using auto or decltype:
auto len = line.size();    //len has type string::size_type

//Becuase size returns an unsigned type, it is essential to remember that expression that mix signed and unsigned data can have surprising results.

//We can use one type where another type is expected if there is a conversion from the given type to the expected type. The string library lets uf convert both character literals and character string literals to strings. 
//When we mix the strings and string or character literals, at least one operand to each + operator must be of string type.

//For historical reasons, and for compatibility with C, string literals are not standard library strings. It is important to remember that these types differ when you use string literals and library strings.

//3.2.3 Dealing with the Characters in a string

//In addition to facilities defined specifically for C++, the C++ library incorporates the C library. Headers in C have names of the form name .h. The C++ versions of these headers are named c name—they remove the .h suffix and precede the name with the letter c. The c indicates that the header is part of the C library.
//Hence, cctype has the same contents as ctype.h, but in a form that is appropriate for C++ programs. In particular, the names defined in the cname headers are defined inside the std namespace, whereas those defined in the .h versions are not.
//Ordinarily, C++ programs should use the cname versions of headers and not the name .h versions. That way names from the standard library are consistently found in the std namespace. Using the .h headers puts the burden on the programmer to remember which library names are inherited from C and which are unique to C++.

//If we want to change the value of the characters in a string, we must define the loop variable as a reference type. Remember that a reference is just another name for a given object. When we use a reference as our control variable, that variable is bound to each element in the sequence in turn. Using the reference, we can change the character to which the reference is bound.
for(auto &c:s) {};

//The subscript operator (the [] operator) takes a string::size_type value that denotes the position of the character we want to access. The operator returns a reference to the character at the given position.
//Subscripts for string start at zero; if s is a string with at least two characters, then s[0] is the first character, the last character is in s[s.size()-1]

//The result of using an index outside this range is undefined. By implication, subscripting an empty string is undefined.

//range-based for: range for statement
for (declaration:expression)
	statement
//expression is an object of a type that represents a sequence, and declaration defines the variable that we’ll use to access the underlying elements in the sequence. On each iteration, the variable in declaration is initialized from the value of the next element in expression.

//The subscript operator (the [ ] operator) takes a string::size_type value that denotes the position of the character we want to access. The operator returns a reference to the character at the given position.

//Caution: Subscripts are Unchecked
//When we use a subscript, we must ensure that the subscript is in range. That is, the subscript must be >= 0 and < the size() of the string. One way to simplify code that uses subscripts is always to use a variable of type string::size_type as the subscript. Because that type is unsigned, we ensure that the subscript cannot be less than zero. When we use a size_type value as the subscript, we need to check only that our subscript is less than value returned by size().
//The library is not required to check the value of an subscript. The result of using an out-of-range subscript is undefined.

//3.3 Library vector Type

//A vector is a collection of objects, all of which have the same type. Every object in the collection has an associated index, which gives access to that object. A vector is often referred to as a container becuase it "contains" other objects.

//Templates are not themselves functions or classes. Instead, they can be thought of as instructions to the compiler for generating classes or functions. The process that the compiler uses to create classes or functions from templates is called instantiation. When we use a template, we specify what kind of class or function we want the compiler to instantiate.

//For a class template, we specify which class to instantiate by supplying additional information, the nature of which depends on the template. How we specify the information is always the same: We supply it inside a pair of angle brackets following the template’s name.

//vector is a template, not a type. Types generated from vector must include the element type, for example, vector<int>.

//3.3.1 Defining and Initializing vectors

vector<T> v1;    //vector that holds object of type T. Default initialization; v1 is empty
vector<T> v2(v1);    //v2 has a copy of each element in v1
vector<T> v2=v1;    //Equivalent to v2(v1), v2 is a copy of the element in v1
vector<T> v3(n, val);    //v3 has n element with value val
vector<T> v4(n);    //v4 has n copies of a value-initialized object
vector<T> v5{a, b, c...};    //v5 has as many elements as there are initializers; elements are initialized by corresponding initializers
vector<T> v5={a, b, c...};    //Equivalent to v5{a, b, c...}







