//Chapter 14

//14.1 Basic Concepts

//Overloaded operators are functions with special names: the keyword operator followed by the symbol for the operator being defined. Like any other function, an overloaded operator has a return type, a parameter list, and a body.
//An overloaded operator function has the same number of parameters as the operator has operands. A unary operator has one parameter; a binary operator has two. In a binary operator, the left-hand operand is passed to the first parameter and the right-hand operand to the second. Except for the overloaded function-call operator, operator(), an overloaded operator may not have default arguments.
//If an operator function is a member function, the first (left-hand) operand is bound to the implicit this pointer. Because the first operand is implicitly bound to this, a member operator function has one less (explicit) parameter than the operator has operands.
//Note: When an overloaded operator is a member function, this is bound to the left-hand operand. Member operator functions have one less (explicit) parameter than the number of operands.
//An operator function must either be a member of a class or have at least one parameter of a class type.
//error: cannot redefine the built-in operator for ints
int operator+ (int, int);
//This restriction means that we cannot change the meaning of an operator when applied to operands of built-in type.
//We can overload only existing operators and cannot invent new operator symbols. For example, we cannot define operator** to provide exponentiation.
//Four symbols (+, -, *, and &) serve as both unary and binary operators. Either or both of these operators can be overloaded. The number of parameters determines which operator is being defined.
//An overloaded operator has the same precedence and associativity as the corresponding built-in operator. Regardless of the operand types
x == y + z;
//is always equivalent to x == (y + z).

//Calling an Overloaded Operator Function Directly
//Ordinarily, we “call” an overloaded operator function indirectly by using the operator on arguments of the appropriate type. However, we can also call an overloaded operator function directly in the same way that we call an ordinary function. We name the function and pass an appropriate number of arguments of the appropriate type:
// equivalent calls to a nonmember operator function
data1 + data2; // normal expression
operator+(data1, data2); // equivalent function call
//These calls are equivalent: Both call the nonmember function operator+, passing data1 as the first argument and data2 as the second.
//We call a member operator function explicitly in the same way that we call any other member function. We name an object (or pointer) on which to run the function and use the dot (or arrow) operator to fetch the function we wish to call:
data1 += data2; // expression-based ''call''
data1.operator+=(data2); // equivalent call to a member operator function
//Each of these statements calls the member function operator+=, binding this to the address of data1 and passing data2 as an argument.

//Some Operators Shouldn’t Be Overloaded
//Recall that a few operators guarantee the order in which operands are evaluated. Because using an overloaded operator is really a function call, these guarantees do not apply to overloaded operators. In particular, the operand-evaluation guarantees of the logical AND, logical OR, and comma operators are not preserved. Moreover, overloaded versions of && or || operators do not preserve short-circuit evaluation properties of the built-in operators. Both operands are always evaluated.
//Because the overloaded versions of these operators do not preserve order of evaluation and/or short-circuit evaluation, it is usually a bad idea to overload them. Users are likely to be surprised when the evaluation guarantees they are accustomed to are not honored for code that happens to use an overloaded version of one of these operators.
//Another reason not to overload comma, which also applies to the address-of operator, is that unlike most operators, the language defines what the comma and address-of operators mean when applied to objects of class type. Because these operators have built-in meaning, they ordinarily should not be overloaded. Users of the class will be surprised if these operators behave differently from their normal meanings.
//Best Practices: Ordinarily, the comma, address-of, logical AND, and logical OR operators should not be overloaded.

//Use Definitions that are Consistent with the Built-in Meaning
//When you design a class, you should always think first about what operations the class will provide. Only after you know what operations are needed should you think about whether to define each operation as an ordinary function or as an overloaded operator. Those operations with a logical mapping to an operator are good candidates for defining as overloaded operators:
//• If the class does IO, define the shift operators to be consistent with how IO is done for the built-in types.
//• If the class has an operation to test for equality, define operator==. If the class has operator==, it should usually have operator!= as well.
//• If the class has a single, natural ordering operation, define operator<. If the class has operator<, it should probably have all of the relational operators.
//• The return type of an overloaded operator usually should be compatible with the return from the built-in version of the operator: The logical and relational operators should return bool, the arithmetic operators should return a value of the class type, and assignment and compound assignment should return a reference to the left-hand operand.

//Assignment and Compound Assignment Operators
//Assignment operators should behave analogously to the synthesized operators: After an assignment, the values in the left-hand and right-hand operands should have the same value, and the operator should return a reference to its left-hand operand. Overloaded assignment should generalize the built-in meaning of assignment, not circumvent it.
//If a class has an arithmetic or bitwise operator, then it is usually a good idea to provide the corresponding compound-assignment operator as well. Needless to say, the += operator should be defined to behave the same way the built-in operators do: it should behave as + followed by =.

//Caution: Use Operator Overloading Judiciously
//Each operator has an associated meaning from its use on the built-in types. Binary +, for example, is strongly identified with addition. Mapping binary + to an analogous operation for a class type can provide a convenient notational shorthand. For example, the library string type, following a convention common to many programming languages, uses + to represent concatenation—“adding” one string to the other.
//Operator overloading is most useful when there is a logical mapping of a built-in operator to an operation on our type. Using overloaded operators rather than inventing named operations can make our programs more natural and intuitive. Overuse or outright abuse of operator overloading can make our classes incomprehensible.
//Obvious abuses of operator overloading rarely happen in practice. As an example, no responsible programmer would define operator+ to perform subtraction. More common, but still inadvisable, are uses that contort an operator’s “normal” meaning to force a fit to a given type. Operators should be used only for operations that are likely to be unambiguous to users. An operator has an ambiguous meaning if it plausibly has more than one interpretation.

//Choosing Member or Nonmember Implementation
//When we define an overloaded operator, we must decide whether to make the operator a class member or an ordinary nonmember function. In some cases, there is no choice—some operators are required to be members; in other cases, we may not be able to define the operator appropriately if it is a member.
//The following guidelines can be of help in deciding whether to make an operator a member or an ordinary nonmember function:
//• The assignment (=), subscript ([]), call (()), and member access arrow (->) operators must be defined as members.
//• The compound-assignment operators ordinarily ought to be members. However, unlike assignment, they are not required to be members.
//• Operators that change the state of their object or that are closely tied to their given type—such as increment, decrement, and dereference—usually should be members.
//• Symmetric operators—those that might convert either operand, such as the arithmetic, equality, relational, and bitwise operators—usually should be defined as ordinary nonmember functions.
//Programmers expect to be able to use symmetric operators in expressions with mixed types. For example, we can add an int and a double. The addition is symmetric because we can use either type as the left-hand or the right-hand operand. If we want to provide similar mixed-type expressions involving class objects, then the operator must be defined as a nonmember function.

//14.2 Input and Output Operators

//14.2.1 Overloading the Output Operator <<

//Ordinarily, the first parameter of an output operator is a reference to a nonconst ostream object. The ostream is nonconst because writing to the stream changes its state. The parameter is a reference because we cannot copy an ostream object.
//The second parameter ordinarily should be a reference to const of the class type we want to print. The parameter is a reference to avoid copying the argument. It can be const because (ordinarily) printing an object does not change that object.
//To be consistent with other output operators, operator<< normally returns its ostream parameter.

//Output Operators Usually Do Minimal Formatting The output operators for the built-in types do little if any formatting. In particular, they do not print newlines. Users expect class output operators to behave similarly. If the operator does print a newline, then users would be unable to print descriptive text along with the object on the same line. An output operator that does minimal formatting lets users control the details of their output.
//Best Practices: Generally, output operators should print the contents of the object, with minimal formatting. They should not print a newline.

//IO Operators Must Be Nonmember Functions
//Input and output operators that conform to the conventions of the iostream library must be ordinary nonmember functions. These operators cannot be members of our own class. If they were, then the left-hand operand would have to be an object of our class type
Sales_data data;
data << cout; // if operator<< is a member of Sales_data
//If these operators are members of any class, they would have to be members of istream or ostream. However, those classes are part of the standard library, and we cannot add members to a class in the library.
//Thus, if we want to define the IO operators for our types, we must define them as nonmember functions. Of course, IO operators usually need to read or write the nonpublic data members. As a consequence, IO operators usually must be declared as friends.

//14.2.2 Overloading the Input Operator >>
//Ordinarily the first parameter of an input operator is a reference to the stream from which it is to read, and the second parameter is a reference to the (nonconst) object into which to read. The operator usually returns a reference to its given stream. The second parameter must be nonconst because the purpose of an input operator is to read data into this object.
//Note: Input operators must deal with the possibility that the input might fail; output operators generally don't bother.

//Errors during Input
//The kinds of errors that might happen in an input operator include the following:
//• A read operation might fail because the stream contains data of an incorrect type. For example, after reading bookNo, the input operator assumes that the next two items will be numeric data. If nonnumeric data is input, that read and any subsequent use of the stream will fail.
//• Any of the reads could hit end-of-file or some other error on the input stream. Rather than checking each read, we check once after reading all the data and before using those data:
if (is) // check that the inputs succeeded
	item.revenue = item.units_sold * price;
else
	item = Sales_data(); // input failed: give the object the default state
//If any of the read operations fails, price will have an undefined value. Therefore, before using price, we check that the input stream is still valid. If it is, we do the calculation and store the result in revenue. If there was an error, we do not worry about which input failed. Instead, we reset the entire object to the empty Sales_data by assigning a new, default-initialized Sales_data object to item. After this assignment, item will have an empty string for its bookNo member, and its revenue and units_sold members will be zero.
//Putting the object into a valid state is especially important if the object might have been partially changed before the error occurred. For example, in this input operator, we might encounter an error after successfully reading a new bookNo. An error after reading bookNo would mean that the units_sold and revenue members of the old object were unchanged. The effect would be to associate a different bookNo with those data.
//By leaving the object in a valid state, we (somewhat) protect a user that ignores the possibility of an input error. The object will be in a usable state—its members are all defined. Similarly, the object won’t generate misleading results—its data are internally consistent.
//Best Practices: Input operators should decide what, if anything, to do about error recovery.

//Indicating Errors
//Some input operators need to do additional data verification. For example, our input operator might check that the bookNo we read is in an appropriate format. In such cases, the input operator might need to set the stream’s condition state to indicate failure, even though technically speaking the actual IO was successful. Usually an input operator should set only the failbit. Setting eofbit would imply that the file was exhausted, and setting badbit would indicate that the stream was corrupted. These errors are best left to the IO library itself to indicate.

//14.3 Arithmetic and Relational Operators
//Ordinarily, we define the arithmetic and relational operators as nonmember functions in order to allow conversions for either the left- or right-hand operand. These operators shouldn’t need to change the state of either operand, so the parameters are ordinarily references to const.
//An arithmetic operator usually generates a new value that is the result of a computation on its two operands. That value is distinct from either operand and is calculated in a local variable. The operation returns a copy of this local as its result. Classes that define an arithmetic operator generally define the corresponding compound assignment operator as well. When a class has both operators, it is usually more efficient to define the arithmetic operator to use compound assignment:
// assumes that both objects refer to the same book
Sales_data operator+(const Sales_data &lhs, const Sales_data &rhs) {
	Sales_data sum = lhs; // copy data members from lhs into sum
	sum += rhs; // add rhs into sum
	return sum;
}
//This definition is essentially identical to our original add function. We copy lhs into the local variable sum. We then use the Sales_data compoundassignment operator (which we’ll define on page 564) to add the values from rhs into sum. We end the function by returning a copy of sum.
//Tip: Classes that define both an arithmetic operator and the related compound assignment ordinarily ought to implement the arithmetic operator by using the compound assignment.

//14.3.1 Equality Operators
//Ordinarily, classes in C++ define the equality operator to test whether two objects are equivalent. That is, they usually compare every data member and treat two objects as equal if and only if all the corresponding members are equal.
//The definition of these functions is trivial. More important are the design principles
that these functions embody:
//• If a class has an operation to determine whether two objects are equal, it should define that function as operator== rather than as a named function: Users will expect to be able to compare objects using ==; providing == means they won’t need to learn and remember a new name for the operation; and it is easier to use the library containers and algorithms with classes that define the == operator.
//• If a class defines operator==, that operator ordinarily should determine whether the given objects contain equivalent data.
//• Ordinarily, the equality operator should be transitive, meaning that if a == b and b == c are both true, then a == c should also be true.
//• If a class defines operator==, it should also define operator!=. Users will expect that if they can use == then they can also use !=, and vice versa.
//• One of the equality or inequality operators should delegate the work to the other. That is, one of these operators should do the real work to compare objects. The other should call the one that does the real work.
//Best Practices: Classes for which there is a logical meaning for equality normally should define operator==. Classes that define == make it easier for users to use the class with the library algorithms.

//14.3.2 Relational Operators
//Classes for which the equality operator is defined also often (but not always) have relational operators. In particular, because the associative containers and some of the algorithms use the less-than operator, it can be useful to define an operator<.
//Ordinarily the relational operators should
//1. Define an ordering relation that is consistent with the requirements for use as a key to an associative container (§ 11.2.2, p. 424); and
//2. Define a relation that is consistent with == if the class has both operators. In particular, if two objects are !=, then one object should be < the other.
//Although we might think our Sales_data class should support the relational operators, it turns out that it probably should not do so. The reasons are subtle and are worth understanding.
//We might think that we’d define < similarly to compareIsbn. That function compared Sales_data objects by comparing their ISBNs. Although compareIsbn provides an ordering relation that meets requirment 1, that function yields results that are inconsistent with our definition of ==. As a result, it does not meet requirement 2.
//The Sales_data == operator treats two transactions with the same ISBN as unequal if they have different revenue or units_sold members. If we defined the < operator to compare only the ISBN member, then two objects with the same ISBN but different units_sold or revenue would compare as unequal, but neither object would be less than the other. Ordinarily, if we have two objects, neither of which is less than the other, then we expect that those objects are equal.
//We might think that we should, therefore, define operator< to compare each data element in turn. We could define operator< to compare objects with equal isbns by looking next at the units_sold and then at the revenue members.
//However, there is nothing essential about this ordering. Depending on how we plan to use the class, we might want to define the order based first on either revenue or units_sold. We might want those objects with fewer units_sold to be “less than” those with more. Or we might want to consider those with smaller revenue “less than” those with more.
//For Sales_data, there is no single logical definition of <. Thus, it is better for this class not to define < at all.
//Best Practices: If a single logical definition for < exists, classes usually should define the < operator. However, if the class also has ==, define < only if the definitions of < and == yield consistent results.

//14.4 Assignment Operators
//In addition to the copy- and move-assignment operators that assign one object of the class type to another object of the same type, a class can define additional assignment operators that allow other types as the right-hand operand.
//As one example, in addition to the copy- and move-assignment operators, the library vector class defines a third assignment operator that takes a braced list of elements. We can use this operator as follows:
vector<string> v;
v = {"a", "an", "the"};
//We can add this operator to our StrVec class (§ 13.5, p. 526) as well:
class StrVec {
  public:
	StrVec &operator=(std::initializer_list<std::string>);
	// other members as in § 13.5 (p. 526)
};
//To be consistent with assignment for the built-in types (and with the copy- and moveassignment operators we already defined), our new assignment operator will return a reference to its left-hand operand:
StrVec &StrVec::operator=(initializer_list<string> il) {
	// alloc_n_copy allocates space and copies elements from the given range
	auto data = alloc_n_copy(il.begin(), il.end());
	free(); // destroy the elements in this object and free the space
	elements = data.first; // update data members to point to the new space
	first_free = cap = data.second;
	return *this;
}
//As with the copy- and move-assignment operators, other overloaded assignment operators have to free the existing elements and create new ones. Unlike the copyand move-assignment operators, this operator does not need to check for selfassignment. The parameter is an initializer_list<string>, which means that il cannot be the same object as the one denoted by this.
//Note: Assignment operators can be overloaded. Assignment operators, regardless of parameter type, must be defined as member functions.

//Compound-Assignment Operators
//Compound assignment operators are not required to be members. However, we prefer to define all assignments, including compound assignments, in the class. For consistency with the built-in compound assignment, these operators should return a reference to their left-hand operand. For example, here is the definition of the Sales_data compound-assignment operator:
// member binary operator: left-hand operand is bound to the implicit this pointer
// assumes that both objects refer to the same book
Sales_data& Sales_data::operator+=(const Sales_data &rhs) {
	units_sold += rhs.units_sold;
	revenue += rhs.revenue;
	return *this;
}
//Best Practices: Assignment operators must, and ordinarily compound-assignment operators should, be defined as members. These operators should return a reference to the left-hand operand.

//14.5 Subscript Operator
//Classes that represent containers from which elements can be retrieved by position often define the subscript operator, operator[].
//Note: The subscript operator must be a member function.
//To be compatible with the ordinary meaning of subscript, the subscript operator usually returns a reference to the element that is fetched. By returning a reference, subscript can be used on either side of an assignment. Consequently, it is also usually a good idea to define both const and nonconst versions of this operator. When applied to a const object, subscript should return a reference to const so that it is not possible to assign to the returned object.
//Best Practices: If a class has a subscript operator, it usually should define two versions: one that returns a plain reference and the other that is a const member and returns a reference to const.

//14.6 Increment and Decrement Operators
//The increment (++) and decrement (--) operators are most often implemented for iterator classes. These operators let the class move between the elements of a sequence. There is no language requirement that these operators be members of the class. However, because these operators change the state of the object on which they operate, our preference is to make them members.
//For the built-in types, there are both prefix and postfix versions of the increment and decrement operators. Not surprisingly, we can define both the prefix and postfix instances of these operators for our own classes as well. We’ll look at the prefix versions first and then implement the postfix ones.
//Best Practices: Classes that define increment or decrement operators should define both the prefix and postfix versions. These operators usually should be defined as members.

//Defining Prefix Increment/Decrement Operators
//To illustrate the increment and decrement operators, we’ll define these operators for our StrBlobPtr class:
//class StrBlobPtr {
  public:
	// increment and decrement
	StrBlobPtr& operator++(); // prefix operators
	StrBlobPtr& operator--();
	// other members as before
};

//Best Practices: To be consistent with the built-in operators, the prefix operators should return a reference to the incremented or decremented object.
//The increment and decrement operators work similarly to each other—they call check to verify that the StrBlobPtr is still valid. If so, check also verifies that its given index is valid. If check doesn’t throw an exception, these operators return a reference to this object.
//In the case of increment, we pass the current value of curr to check. So long as that value is less than the size of the underlying vector, check will return. If curr is already at the end of the vector, check will throw:
// prefix: return a reference to the incremented/decremented object
StrBlobPtr& StrBlobPtr::operator++() {
	// if curr already points past the end of the container, can't increment it
	check(curr, "increment past end of StrBlobPtr");
	++curr; // advance the current state
	return *this;
}
StrBlobPtr& StrBlobPtr::operator--() {
	// if curr is zero, decrementing it will yield an invalid subscript
	--curr; // move the current state back one element
	check(-1, "decrement past begin of StrBlobPtr");
	return *this;
}
//The decrement operator decrements curr before calling check. That way, if curr (which is an unsigned number) is already zero, the value that we pass to check will be a large positive value representing an invalid subscript.

//Differentiating Prefix and Postfix Operators
//There is one problem with defining both the prefix and postfix operators: Normal overloading cannot distinguish between these operators. The prefix and postfix versions use the same symbol, meaning that the overloaded versions of these operators have the same name. They also have the same number and type of operands.
//To solve this problem, the postfix versions take an extra (unused) parameter of type int. When we use a postfix operator, the compiler supplies 0 as the argument for this parameter. Although the postfix function can use this extra parameter, it usually should not. That parameter is not needed for the work normally performed by a postfix operator. Its sole purpose is to distinguish a postfix function from the prefix version.
//We can now add the postfix operators to StrBlobPtr:
class StrBlobPtr {
  public:
	// increment and decrement
	StrBlobPtr operator++(int); // postfix operators
	StrBlobPtr operator--(int);
	// other members as before
};
//Best Practices: To be consistent with the built-in operators, the postfix operators should return the old (unincremented or undecremented) value. That value is returned as a value, not a reference.

//The postfix versions have to remember the current state of the object before incrementing the object:
// postfix: increment/decrement the object but return the unchanged value
StrBlobPtr StrBlobPtr::operator++(int) {
	// no check needed here; the call to prefix increment will do the check
	StrBlobPtr ret = *this; // save the current value
	++*this; // advance one element; prefix ++ checks the increment
	return ret; // return the saved state
}
StrBlobPtr StrBlobPtr::operator--(int) {
	// no check needed here; the call to prefix decrement will do the check
	StrBlobPtr ret = *this; // save the current value
	--*this; // move backward one element; prefix -- checks the decrement
	return ret; // return the saved state
}
//Each of our operators calls its own prefix version to do the actual work. For example, the postfix increment operator executes
++*this
//This expression calls the prefix increment operator. That operator checks that the increment is safe and either throws an exception or increments curr. Assuming check doesn’t throw an exception, the postfix functions return the stored copy in ret. Thus, after the return, the object itself has been advanced, but the value returned reflects the original, unincremented value.
//Note: The int parameter is not used, so we do not give it a name.

//Calling the Postfix Operators Explicitly
//As we saw on page 553, we can explicitly call an overloaded operator as an alternative to using it as an operator in an expression. If we want to call the postfix version using a function call, then we must pass a value for the integer argument:
StrBlobPtr p(a1); // p points to the vector inside a1
p.operator++(0); // call postfix operator++
p.operator++(); // call prefix operator++
//The value passed usually is ignored but is necessary in order to tell the compiler to use the postfix version.

//14.7 Member Access Operators
//The dereference (*) and arrow (->) operators are often used in classes that represent iterators and in smart pointer classes. We can logically add these operators to our StrBlobPtr class as well:
class StrBlobPtr {
  public:
	std::string& operator*() const
	{ auto p = check(curr, "dereference past end");
		return (*p)[curr]; // (*p) is the vector to which this object points
	}
	std::string* operator->() const
	{ // delegate the real work to the dereference operator
		return & this->operator*();
	}
// other members as before
};
//The dereference operator checks that curr is still in range and, if so, returns a reference to the element denoted by curr. The arrow operator avoids doing any work of its own by calling the dereference operator and returning the address of the element returned by that operator.
//Note: Operator arrow must be a member. The dereference operator is not required to be a member but usually should be a member as well.
//It is worth noting that we’ve defined these operators as const members. Unlike the increment and decrment operators, fetching an element doesn’t change the state of a StrBlobPtr. Also note that these operators return a reference or pointer to nonconst string. They do so because we know that a StrBlobPtr can only be bound to a nonconst StrBlob.
//We can use these operators the same way that we’ve used the corresponding operations on pointers or vector iterators:
StrBlob a1 = {"hi", "bye", "now"};
StrBlobPtr p(a1); // p points to the vector inside a1
*p = "okay"; // assigns to the first element in a1
cout << p->size() << endl; // prints 4, the size of the first element in a1
cout << (*p).size() << endl; // equivalent to p->size()

//Constraints on the Return from Operator Arrow
//As with most of the other operators (although it would be a bad idea to do so), we can define operator* to do whatever processing we like. That is, we can define operator* to return a fixed value, say, 42, or print the contents of the object to which it is applied, or whatever. The same is not true for overloaded arrow. The arrow operator never loses its fundamental meaning of member access. When we overload arrow, we change the object from which arrow fetches the specified member. We cannot change the fact that arrow fetches a member.
//When we write point->mem, point must be a pointer to a class object or it must be an object of a class with an overloaded operator->. Depending on the type of point, writing point->mem is equivalent to
(*point).mem; // point is a built-in pointer type
point.operator()->mem; // point is an object of class type
//Otherwise the code is in error. That is, point->mem executes as follows:
//1. If point is a pointer, then the built-in arrow operator is applied, which means this expression is a synonym for (*point).mem. The pointer is dereferenced and the indicated member is fetched from the resulting object. If the type pointed to by point does not have a member named mem, then the code is in error.
//2. If point is an object of a class that defines operator->, then the result of point.operator->() is used to fetch mem. If that result is a pointer, then step 1 is executed on that pointer. If the result is an object that itself has an overloaded operator->(), then this step is repeated on that object. This process continues until either a pointer to an object with the indicated member is returned or some other value is returned, in which case the code is in error.
//Note:The overloaded arrow operator must return either a pointer to a class type or an object of a class type that defines its own operator arrow.


