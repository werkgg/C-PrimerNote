//Chapter02 Variables and Basic Types

//2.1 Primitive Build-in Types

//2.1.1 Arithmetic Types

//Types determine the meaning of the data and operations in our programs.
//C++ defines a set of primitive types that include the arithmetic types and a special type named void.
//The arithmetic types represent characters, intergers, boolean values, and floating-point numbers.
//The void type has no associated values and can be used in only a few circumstances, most commonly as the return type for functions that do not return a value.

//Although threre are three character types, there are only two representations: signed and unsigned. The (Plain) char type uses one of these representations. Which of the other two character representations is equivalent to char depends on the compiler.
//char is signed on some machines and unsigned on others.
//use double for floating-point computations; float usually does not have enough precision, and the cost of double-precision calculations versus single-precision is negligible.

//2.1.2 Type Conversions

//If we assign an out-of-range value to an object of unsigned type, the result is the remainder of the value modulo the number of values the target type can hold.
//If we assign an out-of-range value to an object of signed type, the result is undefined.

//If we use both unsigned and int values in an arithmetic expression, the int value ordinarily is converted to unsigned.

//2.1.3 Literals
//Integer literals that begin with 0(zero) are interpreted as octal. Those that begin with either 0x or 0X are interpreted as hexadecimal.
//Although integer literals may be stored in signed types, technically speaking, the value of a decimal literal is never a negative number. The minus sign is not part of the literal. The minus sign is an operator that negates the value of its literal operand.

//A character enclosed within single quotes is a literal of type char.
//Zero or more characters enclosed in double quotation marks is a string literal.
//The type of a string literal is array of contant chars. The compiler appends a null character ('\0') to every string literal. Thus, the actual size of a string literal is one more than its apparent size.

//We can write a generalized escape sequence, which is \x followed by one or more hexadecimal digits or a \ followed by one, two, or three octal digits.
//Note that if a \ is followed by more than three octal digits, only the first three are associated with the \.

//2.2 Variables

//2.2.1 Variable Definitions

//A simple variable definition consists of a type specifier, followed by a list of one or more variable names separated by commas, and ends with a semicolon.
//A definition may (optionally) provide an initial value for one or more of the names it defines.

//"string" is a library type, representing a variable-length sequence of characters.

//An "object" is a region of memory that can obtain data and has a type.

//An object that is initialized gets the specific value at the moment it is created. The values used to initilize a variable can be arbitrarily complicated expressions.

//Initialization and assignment are different operations in C++!
//Initialization is not assignment. Initialization happens when a variable is given a value when it is created. Assignment obliterates an object's current value and replaces that value with a new one.

//list initialization

//One way in which initialization is a complicated topic is that the language defines several different forms of initilization.
//For example, we can use any of the following four different ways to define an int variable named units_sold and initialize it to 0:
int units_sold = 0;
int units_sold = {0};    //list initialization
int units_sold{0};
int units_sold(0);

//When used with variables of built-in types, this form of initialization has one important property: The compiler will not let us list initialize variables of built-in type if the initializer might lead to the loss of information:
long double ld=3.1415926536;
int a{ld}, b={ld};    //error: narrowing conversion required
int c(ld), d=ld;    //ok, but value will be truncated.

//default initialization
//When we define a variable without an initializer, the variable is default initialized. Such variables are given the "default" value. What that default value is depends on the type of the variable and may also depends on where the variable is defined.

//The value of an object of built-in type that is not explicitly initialized depends on where it is defined. Variables defined outside any function body are initialized to zero. Uninitialized objects of built-in type defined inside a function body have undefined value.
//Objects of class type that we do not explicitly initialize have a value that is defined by the class.

//2.2.2 Variable Declarations and Definitions

//Separate compilation lets us split our programs into several files, each of which can be compiled independently.
//When we separate a program into multiple files, we need a way to share code across those files. 

//What happens when we use an uninitialized variable is undefined. 
//We recommend initializing every object of built-in type. It is not always necessary, but it is easier and safer to provide an initilizer until you can be certain it is safe to omit the initializer.

//To support separate compilation, C++ distinguishes between declarations and definitions. A declaration makes a name known to the program. A file that wants to use a name defined eslewhere includes a declaration for that name. A definition creates the associated entity.

//A variable declaration specifies the type and name of a variable. A variable definition is a declaration. In addition to specifying the name and type, a definition also allocates storage and may provide the variable with an initial value.

//To obtain a declaration that is not also a definition, we add the "extern" keyword and may not provide an explicit initializer.
extern int i;    //declares but does not define i
int j;    //declares and defines j
//Any declaration that includes an explicit initializer is a definition.
//We can provide an initializer on a variable defined as extern, but doing so overrides the extern. An extern that has an initilizer is a definition.
//It is an error to provide an initilizer on an extern inside a function.

//Variables must be defined exactly once but can be declared many times.

//The distinction between a declaration and a definition may seem obscure at this point but is actually important. To use a variable in more than one file requires declarations that are separate from the variable’s definition. To use the same variable in multiple files, we must define that variable in one—and only one—file. Other files that use that variable must declare—but not define—that variable.

//C++ is a statically typed language, which means that types are checked at compile time. The process by which types are checked is referred to as type checking.

//2.2.3 Identifiers

//2.2.4 Scope of a Name

//A scope is a part of the program in which a name has a particular meaning. Most scopes in C++ are delimited by curly braces.
//The same name can refer to different entities in different scope.
//Names are visible from the point where they are declared until the end of the scope in which the declaration appears.

//When the scope operator has an empty left-hand side, it is a request to fetch the name on the right-hand side from the global scope.

//2.3 Compound Types

//A compound type is a type that is defined in terms of another type.
//More generally, a declaration is a base type followed by a list of declarators. Each declarator names a variable and gives the variable a type that is related to the base type.

//2.3.1
//A reference defines an alternative name for an object. A reference type "refers to" another type.
//Ordinarily, when we initialize the variable, the value of the initializer is copied into the object we are creating. When we define a reference, instread of copying the initializer's value, we BIND the reference to its initializer. Once initialized, a reference remains bound to its initial object.
//There is no way to rebind a reference to refer to a different object. Because there is no way to rebind a reference. references must be initialized.

//A reference is not an object. Instread, a reference is just another name for an already existing object.

//After a reference has been defined, all operations on that reference are actually operations on the object to which the reference is bound.

//Because references are not objects, we may not define a reference to a reference.

//2.3.2 Pointers

//A pointer is a compund type that "points to" another type.
//Like references, pointers are used for indirect access to other objects. Unlike a reference, a pointer is an object in its own right. Pointers can be assigned and copied; a single pointer can point to several different objects over its lifetime. Unlike a reference, a pointer need not be initialized at the time it is defined. Like other built-in types, pointers defined at block scope have undefined value if they are not initialized.

//We get the address of an object by using the address-of operator (the & operator).
//Because references are not objects, they don't have addresses. Hence, we may not define a pointer to a reference.

//The value (the address) stored in a pointer can be in one of four states:
//1. it can point to an object.
//2. it can point to the location just immediately past the end of an object.
//3. it can be a null pointer, indicating that it is not bound to any object.
//4. it can be invalid; values other than the preceding three are invalid.

//When a pointer points to an object, we can use the dererence operator ( the * operator) to access that object.
//Derefencing a pointer yields the object to which the pointer points.

//In declarations, & and * are used to form compound types. In expressions, these same symbols are used to denote an operator.

//A null pointer does not point to any object. There are several ways to obtain a null pointer:
int *p = nullptr;
int *p = 0;
int *p = NULL;    //must #include cstdlib

//The preprocessor is a program that runs before the compiler. Preprocessor variables are managed by the preprocessor, and are not part of the std namespace.

//The type void* is a special pointer type that can hold the address of any object.
//A void* pointer holds an address, but the type of the object at that address is unknown.
void*  //

//There are only a limited number of things we can do with a void* pointer: we can compare it to another pointer, we can pass it to or return it from a function, and we can assign it to another void* pointer.
//We cannot use a void* to operator on the object it addresses, as we don't know that object's type, and the type determines what operations we can perform on th

//Generally, we use a void* pointer to deal with memory as memory, rather than using the pointer to access the object stored in that memory.

//2.3.3 Understanding Compound Type Declarations
//A variable definition consists of a base type and a list of declarators.
//Each declarator can relate its variable to the base type differently from the other declarators in the same definition. Thus a single definition might define variables of different types.
int i=1024, *p=&i, &r=i;

//* and & are all type modifiers.

//Both of the following is valid, I prefer the first one:)
int *p;
int* p;

//Reference to pointer
int i=42;
int *p;       //p is a pointer to int
int *&r=p;    //r is a reference to the pointer p
r=&i;         //r refers to a pointer; assigning &i to r makes p point to i
*r=0;         //deferencing r yields i, the object to which p points; changes i to 0

//To understand the type of r, to read the definition from right to left.
//The symbol closest to the name of the variable (in this case the & in &r) is the one that has the most immediate effect on the variable's type. Thus, we know that r is a  reference. The rest of the declarator determines the type to which r refers. The next symbol, * in this case, says that the type r refers to is a pointer type. Finally, the base type of the declarator says that r is a reference to a pointer to an int.

//It can be easier to understand complicated pointer or reference declaration if you read them from right to left.

//2.4 const Qualifier

//We can make a variable unchangeable by defining the variable's type as "const".
//This is to define a variable value as constant. Any attempt to assign another value is an error.

//Because we can't change the value of a const object after we create it, it must be initialized. As usual, the initializer may be an arbitrarily complicated expression.

const int bufSize=512;
//The compiler will generate code using the value of 512 in the places that our code uses bufSize.

//By default, const objects are local to a file.

//Sometimes, we want the const object to behave like other (nonconst) variables. We want to define the const in one file, and declare it in the other files that use that object.
//To define a single instance of a const variable, we use the keyword extern on both its definition and declaration(s).
//file_1.cc defines and initializes a const that is accessible to other files
extern const int bufSize=fcn();  //this is a definition
//file_1.h
extern const int bufferSize;  //same bufSize as defined in file_1.cc

//To share a const object among multiple files, you must define the variable as extern.

//2.4.1 References to const

//As with any other object, we can bind a reference to an object of a const type. To do so we use a reference to const, which is a reference that refers to a const type.
//Unlike an ordinary reference, a reference to const cannot be used to change the object to which the reference is bound.

//const reference is a reference to const.
//C++ programmers tend to abbreviate the phrase "reference to const" as "const reference".

//We noted that there are two exceptions to the rule that the type of a reference must match the type of the object to which it refers.
//The first exception is that we can initialize a reference to const from any expression that can be converted to the type of the reference.






