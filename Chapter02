//Chapter02 Variables and Basic Types

//2.1 Primitive Build-in Types

//2.1.1 Arithmetic Types

//Types determine the meaning of the data and operations in our programs.
//C++ defines a set of primitive types that include the arithmetic types and a special type named void.
//The arithmetic types represent characters, intergers, boolean values, and floating-point numbers.
//The void type has no associated values and can be used in only a few circumstances, most commonly as the return type for functions that do not return a value.

//Although threre are three character types, there are only two representations: signed and unsigned. The (Plain) char type uses one of these representations. Which of the other two character representations is equivalent to char depends on the compiler.
//char is signed on some machines and unsigned on others.
//use double for floating-point computations; float usually does not have enough precision, and the cost of double-precision calculations versus single-precision is negligible.

//2.1.2 Type Conversions

//If we assign an out-of-range value to an object of unsigned type, the result is the remainder of the value modulo the number of values the target type can hold.
//If we assign an out-of-range value to an object of signed type, the result is undefined.

//If we use both unsigned and int values in an arithmetic expression, the int value ordinarily is converted to unsigned.

//2.1.3 Literals
//Integer literals that begin with 0(zero) are interpreted as octal. Those that begin with either 0x or 0X are interpreted as hexadecimal.
//Although integer literals may be stored in signed types, technically speaking, the value of a decimal literal is never a negative number. The minus sign is not part of the literal. The minus sign is an operator that negates the value of its literal operand.

//A character enclosed within single quotes is a literal of type char.
//Zero or more characters enclosed in double quotation marks is a string literal.
//The type of a string literal is array of contant chars. The compiler appends a null character ('\0') to every string literal. Thus, the actual size of a string literal is one more than its apparent size.

//We can write a generalized escape sequence, which is \x followed by one or more hexadecimal digits or a \ followed by one, two, or three octal digits.
//Note that if a \ is followed by more than three octal digits, only the first three are associated with the \.

//2.2 Variables

//2.2.1 Variable Definitions

//A simple variable definition consists of a type specifier, followed by a list of one or more variable names separated by commas, and ends with a semicolon.
//A definition may (optionally) provide an initial value for one or more of the names it defines.

//"string" is a library type, representing a variable-length sequence of characters.

//An "object" is a region of memory that can obtain data and has a type.

//An object that is initialized gets the specific value at the moment it is created. The values used to initilize a variable can be arbitrarily complicated expressions.

//Initialization and assignment are different operations in C++!
//Initialization is not assignment. Initialization happens when a variable is given a value when it is created. Assignment obliterates an object's current value and replaces that value with a new one.

//list initialization

//One way in which initialization is a complicated topic is that the language defines several different forms of initilization.
//For example, we can use any of the following four different ways to define an int variable named units_sold and initialize it to 0:
int units_sold = 0;
int units_sold = {0};    //list initialization
int units_sold{0};
int units_sold(0);

//When used with variables of built-in types, this form of initialization has one important property: The compiler will not let us list initialize variables of built-in type if the initializer might lead to the loss of information:
long double ld=3.1415926536;
int a{ld}, b={ld};    //error: narrowing conversion required
int c(ld), d=ld;    //ok, but value will be truncated.

//default initialization
//When we define a variable without an initializer, the variable is default initialized. Such variables are given the "default" value. What that default value is depends on the type of the variable and may also depends on where the variable is defined.

//The value of an object of built-in type that is not explicitly initialized depends on where it is defined. Variables defined outside any function body are initialized to zero. Uninitialized objects of built-in type defined inside a function body have undefined value.
//Objects of class type that we do not explicitly initialize have a value that is defined by the class.

//2.2.2 Variable Declarations and Definitions

//Separate compilation lets us split our programs into several files, each of which can be compiled independently.
//When we separate a program into multiple files, we need a way to share code across those files. 

//What happens when we use an uninitialized variable is undefined. 
//We recommend initializing every object of built-in type. It is not always necessary, but it is easier and safer to provide an initilizer until you can be certain it is safe to omit the initializer.

//To support separate compilation, C++ distinguishes between declarations and definitions. A declaration makes a name known to the program. A file that wants to use a name defined eslewhere includes a declaration for that name. A definition creates the associated entity.

//A variable declaration specifies the type and name of a variable. A variable definition is a declaration. In addition to specifying the name and type, a definition also allocates storage and may provide the variable with an initial value.

//To obtain a declaration that is not also a definition, we add the "extern" keyword and may not provide an explicit initializer.
extern int i;    //declares but does not define i
int j;    //declares and defines j
//Any declaration that includes an explicit initializer is a definition.
//We can provide an initializer on a variable defined as extern, but doing so overrides the extern. An extern that has an initilizer is a definition.
//It is an error to provide an initilizer on an extern inside a function.

//Variables must be defined exactly once but can be declared many times.

//The distinction between a declaration and a definition may seem obscure at this point but is actually important. To use a variable in more than one file requires declarations that are separate from the variable’s definition. To use the same variable in multiple files, we must define that variable in one—and only one—file. Other files that use that variable must declare—but not define—that variable.

//C++ is a statically typed language, which means that types are checked at compile time. The process by which types are checked is referred to as type checking.

//2.2.3 Identifiers

//2.2.4 Scope of a Name



