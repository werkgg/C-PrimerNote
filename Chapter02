//Chapter02 Variables and Basic Types

//2.1 Primitive Build-in Types

//2.1.1 Arithmetic Types

//Types determine the meaning of the data and operations in our programs.
//C++ defines a set of primitive types that include the arithmetic types and a special type named void.
//The arithmetic types represent characters, intergers, boolean values, and floating-point numbers.
//The void type has no associated values and can be used in only a few circumstances, most commonly as the return type for functions that do not return a value.

//Although threre are three character types, there are only two representations: signed and unsigned. The (Plain) char type uses one of these representations. Which of the other two character representations is equivalent to char depends on the compiler.
//char is signed on some machines and unsigned on others.
//use double for floating-point computations; float usually does not have enough precision, and the cost of double-precision calculations versus single-precision is negligible.

//2.1.2 Type Conversions

//If we assign an out-of-range value to an object of unsigned type, the result is the remainder of the value modulo the number of values the target type can hold.
//If we assign an out-of-range value to an object of signed type, the result is undefined.

//If we use both unsigned and int values in an arithmetic expression, the int value ordinarily is converted to unsigned.

//2.1.3 Literals
//Integer literals that begin with 0(zero) are interpreted as octal. Those that begin with either 0x or 0X are interpreted as hexadecimal.
//Although integer literals may be stored in signed types, technically speaking, the value of a decimal literal is never a negative number. The minus sign is not part of the literal. The minus sign is an operator that negates the value of its literal operand.

//A character enclosed within single quotes is a literal of type char.
//Zero or more characters enclosed in double quotation marks is a string literal.
//The type of a string literal is array of contant chars. The compiler appends a null character ('\0') to every string literal. Thus, the actual size of a string literal is one more than its apparent size.

//We can write a generalized escape sequence, which is \x followed by one or more hexadecimal digits or a \ followed by one, two, or three octal digits.
//Note that if a \ is followed by more than three octal digits, only the first three are associated with the \.

//2.2 Variables

//2.2.1 Variable Definitions

//A simple variable definition consists of a type specifier, followed by a list of one or more variable names separated by commas, and ends with a semicolon.
//A definition may (optionally) provide an initial value for one or more of the names it defines.

//"string" is a library type, representing a variable-length sequence of characters.

//An "object" is a region of memory that can obtain data and has a type.

//An object that is initialized gets the specific value at the moment it is created. The values used to initilize a variable can be arbitrarily complicated expressions.

//Initialization and assignment are different operations in C++!
//Initialization is not assignment. Initialization happens when a variable is given a value when it is created. Assignment obliterates an object's current value and replaces that value with a new one.

//list initialization

//One way in which initialization is a complicated topic is that the language defines several different forms of initilization.
//For example, we can use any of the following four different ways to define an int variable named units_sold and initialize it to 0:
int units_sold = 0;
int units_sold = {0};    //list initialization
int units_sold{0};
int units_sold(0);

//When used with variables of built-in types, this form of initialization has one important property: The compiler will not let us list initialize variables of built-in type if the initializer might lead to the loss of information:
long double ld=3.1415926536;
int a{ld}, b={ld};    //error: narrowing conversion required
int c(ld), d=ld;    //ok, but value will be truncated.

//default initialization
//When we define a variable without an initializer, the variable is default initialized. Such variables are given the "default" value. What that default value is depends on the type of the variable and may also depends on where the variable is defined.

//The value of an object of built-in type that is not explicitly initialized depends on where it is defined. Variables defined outside any function body are initialized to zero. Uninitialized objects of built-in type defined inside a function body have undefined value.
//Objects of class type that we do not explicitly initialize have a value that is defined by the class.

//2.2.2 Variable Declarations and Definitions



