//Chapter10 Generic Algorithms

//10.1 Overview

//Most of the algorithms are defined in the algorithm header. The library also defines a set of generic numeric algorithms that are defined in the numeric header.
//In general, the algorithms do not work directly on a container. Instead, they operate by traversing a range of elements bounded by two iterators. Typically, as the algorithm traverses the range, it does something with each element.

//How the Algorithms Work

//To see how the algorithms can be used on varying types of containers, let’s look a bit more closely at find. Its job is to find a particular element in an unsorted sequence of elements. Conceptually, we can list the steps find must take:
//1. It accesses the first element in the sequence.
//2. It compares that element to the value we want.
//3. If this element matches the one we want, find returns a value that identifies/this element.
//4. Otherwise, find advances to the next element and repeats steps 2 and 3.
//5. find must stop when it has reached the end of the sequence.
//6. If find gets to the end of the sequence, it needs to return a value indicating that the element was not found. This value and the one returned from step 3 must have compatible types.
//None of these operations depends on the type of the container that holds the/elements. So long as there is an iterator that can be used to access the elements,/find doesn’t depend in any way on the container type (or even whether the elements/are stored in a container).

//Key Concept: Algorithms Never Execute Container Operations
//The generic algorithms do not themselves execute container operations. They operate solely in terms of iterators and iterator operations. The fact that the algorithms operate in terms of iterators and not container operations has a perhaps surprising but essential implication: Algorithms never change the size of the underlying container. Algorithms may change the values of the elements stored in the container, and they may move elements around within the container. They do not, however, ever add or remove elements directly.
//As we’ll see in § 10.4.1 (p. 401), there is a special class of iterator, the inserters, that do more than traverse the sequence to which they are bound. When we assign to these iterators, they execute insert operations on the underlying container. When an algorithm operates on one of these iterators, the iterator may have the effect of adding elements to the container. The algorithm itself, however, never does so.

//10.2 A First Look at the Algorithms

//The library provides more than 100 algorithms. Fortunately, like the containers, the algorithms have a consistent architecture. Understanding this architecture makes learning and using the algorithms easier than memorizing all 100+ of them. In this chapter, we’ll illustrate how to use the algorithms, and describe the unifying principles that characterize them. Appendix A lists all the algorithms classified by how they operate.
//With only a few exceptions, the algorithms operate over a range of elements. We’ll refer to this range as the “input range.” The algorithms that take an input range always use their first two parameters to denote that range. These parameters are iterators denoting the first and one past the last elements to process.
//Although most algorithms are similar in that they operate over an input range, they differ in how they use the elements in that range. The most basic way to understand the algorithms is to know whether they read elements, write elements, or rearrange the order of the elements.

//10.2.1 Read-Only Algorithms

//A number of the algorithms read, but never write to, the elements in their input range. The find function is one such algorithm.
//Another read-only algorithm is accumulate, which is defined in the numeric header. The accumulate function takes three arguments. The first two specify a range of elements to sum. The third is an initial value for the sum.

//Note: The type of the third argument to accumulate determines which addition operator is used and is the type that accumulate returns.
//Best Practices: Ordinarily it is best to use cbegin() and cend() with algorithms that read, but do not write, the elements. However, if you plan to use the iterator returned by the algorithm to change an element’s value, then you need to pass begin() and end().

//Algorithms that Operate on Two Sequences

//Another read-only algorithm is equal, which lets us determine whether two sequences hold the same values. It compares each element from the first sequence to the corresponding element in the second. It returns true if the corresponding elements are equal, false otherwise. The algorithm takes three iterators: The first two (as usual) denote the range of elements in the first sequence; the third denotes the first element in the second sequence:
// roster2 should have at least as many elements as roster1
equal(roster1.cbegin(), roster1.cend(), roster2.cbegin());
//Because equal operates in terms of iterators, we can call equal to compare elements in containers of different types. Moreover, the element types also need not be the same so long as we can use == to compare the element types. For example, roster1 could be a vector<string> and roster2 a list<const char*>.
//However, equal makes one critically important assumption: It assumes that the second sequence is at least as big as the first. This algorithm potentially looks at every element in the first sequence. It assumes that there is a corresponding element for each of those elements in the second sequence.

//Warning: Algorithms that take a single iterator denoting a second sequence assume that the second sequence is at least as large at the first.

//10.2.2 Algorithms that Write Container Elements

//Some algorithms assign new values to the elements in a sequence. When we use an algorithm that assigns to elements, we must take care to ensure that the sequence into which the algorithm writes is at least as large as the number of elements we ask the algorithm to write. Remember, algorithms do not perform container operations, so they have no way themselves to change the size of a container.
//Some algorithms write to elements in the input range itself. These algorithms are not inherently dangerous because they write only as many elements as are in the specified range.
//As one example, the fill algorithm takes a pair of iterators that denote a range and a third argument that is a value. fill assigns the given value to each element in the input sequence:
fill(vec.begin(), vec.end(), 0); // reset each element to 0
// set a subsequence of the container to 10
fill(vec.begin(), vec.begin() + vec.size()/2, 10);
//Because fill writes to its given input sequence, so long as we pass a valid input sequence, the writes will be safe.

//Key Concept: Iterator Arguments 
//Some algorithms read elements from two sequences. The elements that constitute these sequences can be stored in different kinds of containers. For example, the first sequence might be stored in a vector and the second might be in a list, a deque, a built-in array, or some other sequence. Moreover, the element types in the two sequences are not required to match exactly. What is required is that we be able to compare elements from the two sequences. For example, in the equal algorithm, the element types need not be identical, but we do have to be able to use == to compare elements from the two sequences.
//Algorithms that operate on two sequences differ as to how we pass the second sequence. Some algorithms, such as equal, take three iterators: The first two denote the range of the first sequence, and the third iterator denotes the first element in the second sequence. Others take four iterators: The first two denote the range of elements in the first sequence, and the second two denote the range for the second sequence.
//Algorithms that use a single iterator to denote the second sequence assume that the second sequence is at least as large as the first. It is up to us to ensure that the algorithm will not attempt to access a nonexistent element in the second sequence. For example, the equal algorithm potentially compares every element from its first sequence to an element in the second. If the second sequence is a subset of the first, then our program has a serious error—equal will attempt to access elements beyond the end of the second sequence.

//Algorithms do not Check Write Operations

//Some algorithms take an iterator that denotes a separate destination. These algorithms assign new values to the elements of a sequence starting at the element denoted by the destination iterator. For example, the fill_n function takes a single iterator, a count, and a value. It assigns the given value to the specified number of elements starting at the element denoted to by the iterator. We might use fill_n to assign a new value to the elements in a vector:
vector<int> vec; // empty vector
// use vec giving it various values
fill_n(vec.begin(), vec.size(), 0); // reset all the elements of vec to 0
//The fill_n function assumes that it is safe to write the specified number of elements. That is, for a call of the form
fill_n(dest, n, val)
//fill_n assumes that dest refers to an element and that there are at least n elements in the sequence starting from dest.
//It is a fairly common beginner mistake to call fill_n (or similar algorithms that write to elements) on a container that has no elements:
vector<int> vec; // empty vector
// disaster: attempts to write to ten (nonexistent) elements in vec
fill_n(vec.begin(), 10, 0);
//This call to fill_n is a disaster. We specified that ten elements should be written, but there are no such elements—vec is empty. The result is undefined.

//Warning: Algorithms that write to a destination iterator assume the destination is large enough to hold the number of elements being written.

//Introducing back_inserter

//One way to ensure that an algorithm has enough elements to hold the output is to use an insert iterator. An insert iterator is an iterator that adds elements to a container. Ordinarily, when we assign to a container element through an iterator, we assign to the element that iterator denotes. When we assign through an insert iterator, a new element equal to the right-hand value is added to the container.
//We’ll have more to say about insert iterators in § 10.4.1 (p. 401). However, in order to illustrate how to use algorithms that write to a container, we will use back_inserter, which is a function defined in the iterator header.
//back_inserter takes a reference to a container and returns an insert iterator bound to that container. When we assign through that iterator, the assignment calls push_back to add an element with the given value to the container:

vector<int> vec;    //empty vector;
auto it=back_inserter(vec);    //assigning through it adds elements to vec;
*it=42;    //vec now has one element with value 42;
//We frequently use back_inserter to create an iterator to use as the destination of an algorithm. For example:
vector<int> vec; // empty vector
// ok: back_inserter creates an insert iterator that adds elements to vec
fill_n(back_inserter(vec), 10, 0); // appends ten elements to vec
//On each iteration, fill_n assigns to an element in the given sequence. Because we passed an iterator returned by back_inserter, each assignment will call push_back on vec. As a result, this ca

//Copy Algorithms

//The copy algorithm is another example of an algorithm that writes to the elements of an output sequence denoted by a destination iterator. This algorithm takes three iterators. The first two denote an input range; the third denotes the beginning of the destination sequence. This algorithm copies elements from its input range into elements in the destination. It is essential that the destination passed to copy be at least as large as the input range.
//As one example, we can use copy to copy one built-in array to another:
int a1[] = {0,1,2,3,4,5,6,7,8,9};
int a2[sizeof(a1)/sizeof(*a1)]; // a2 has the same size as a1
// ret points just past the last element copied into a2
auto ret = copy(begin(a1), end(a1), a2); // copy a1 into a2
//Here we define an array named a2 and use sizeof to ensure that a2 has as many elements as the array a1. We then call copy to copy a1 into a2. After the call to copy, the elements in both arrays have the same values.
//The value returned by copy is the (incremented) value of its destination iterator. That is, ret will point just past the last element copied into a2.
//Several algorithms provide so-called “copying” versions. These algorithms compute new element values, but instead of putting them back into their input sequence, the algorithms create a new sequence to contain the results.
//For example, the replace algorithm reads a sequence and replaces every instance of a given value with another value. This algorithm takes four parameters: two iterators denoting the input range, and two values. It replaces each element that is equal to the first value with the second:
// replace any element with the value 0 with 42
replace(ilst.begin(), ilst.end(), 0, 42);
//This call replaces all instances of 0 by 42. If we want to leave the original sequence unchanged, we can call replace_copy. That algorithm takes a third iterator argument denoting a destination in which to write the adjusted sequence:
// use back_inserter to grow destination as needed
replace_copy(ilst.cbegin(), ilst.cend(),
back_inserter(ivec), 0, 42);
//After this call, ilst is unchanged, and ivec contains a copy of ilst with the exception that every element in ilst with the value 0 has the value 42 in ivec.

//10.2.3 Algorithms that Reorder Container Elements

//Some algorithms rearrange the order of elements within a container. An obvious example of such an algorithm is sort. A call to sort arranges the elements in the input range into sorted order using the element type’s < operator.

//To eliminate the duplicated words, we will first sort the vector so that duplicated words appear adjacent to each other. Once the vector is sorted, we can use another library algorithm, named unique, to reorder the vector so that the unique elements appear in the first part of the vector. Because algorithms cannot do container operations, we’ll use the erase member of vector to actually remove the elements:
void elimDups(vector<string> &words){
	// sort words alphabetically so we can find the duplicates
	sort(words.begin(), words.end());
	// unique reorders the input range so that each word appears once in the front portion of the range and returns an iterator one past the unique range
	auto end_unique = unique(words.begin(), words.end());
	// erase uses a vector operation to remove the nonunique elements
	words.erase(end_unique, words.end());
}

//The unique algorithm rearranges the input range to “eliminate” adjacent duplicated entries, and returns an iterator that denotes the end of the range of the unique values.
//The size of words is unchanged; it still has ten elements. The order of those elements is changed—the adjacent duplicates have been “removed.” We put remove in quotes because unique doesn’t remove any elements. Instead, it overwrites adjacent duplicates so that the unique elements appear at the front of the sequence. The iterator returned by unique denotes one past the last unique element. The elements beyond that point still exist, but we don’t know what values they have.

//Note: The library algorithms operate on iterators, not containers. Therefore, an algorithm cannot (directly) add or remove elements.

//10.3 Customizing Operations

//Many of the algorithms compare elements in the input sequence. By default, such algorithms use either the element type’s < or == operator. The library also defines versions of these algorithms that let us supply our own operation to use in place of the default operator.
//For example, the sort algorithm uses the element type’s < operator. However, we might want to sort a sequence into a different order from that defined by <, or our sequence might have elements of a type (such as Sales_data) that does not have a < operator. In both cases, we need to override the default behavior of sort.

//10.3.1 Passing a Function on to Algorithm

//As one example, assume that we want to print the vector after we call elimDups. However, we’ll also assume that we want to see the words ordered by their size, and then alphabetically within each size. To reorder the vector by length, we’ll use a second, overloaded version of sort. This version of sort takes a third argument that is a predicate.

//Predicates

//A predicate is an expression that can be called and that returns a value that can be used as a condition. The predicates used by library algorithms are either unary predicates (meaning they have a single parameter) or binary predicates (meaning they have two parameters). The algorithms that take predicates call the given predicate on the elements in the input range. As a result, it must be possible to convert the element type to the parameter type of the predicate.

//The version of sort that takes a binary predicate uses the given predicate in place of < to compare elements. The predicates that we supply to sort must meet the requirements that we’ll describe in. For now, what we need to know is that the operation must define a consistent order for all possible elements in the input sequence. Our isShorter function from is an example of a function that meets these requirements, so we can pass isShorter to sort. Doing so will reorder the elements by size:
// comparison function to be used to sort by word length
bool isShorter(const string &s1, const string &s2) {
	return s1.size() < s2.size();
}
// sort on word length, shortest to longest
sort(words.begin(), words.end(), isShorter);
//If words contains the same data as in § 10.2.3 (p. 384), this call would reorder words so that all the words of length 3 appear before words of length 4, which in turn are followed by words of length 5, and so on.

//Sorting Algorithms

//When we sort words by size, we also want to maintain alphabetic order among the elements that have the same length. To keep the words of the same length in alphabetical order we can use the stable_sort algorithm. A stable sort maintains the original order among equal elements.
//Ordinarily, we don’t care about the relative order of equal elements in a sorted sequence. After all, they’re equal. However, in this case, we have defined “equal” to mean “have the same length.” Elements that have the same length still differ from one another when we view their contents. By calling stable_sort, we can maintain alphabetical order among those elements that have the same length:
elimDups(words); // put words in alphabetical order and remove duplicates
// resort by length, maintaining alphabetical order among words of the same length
stable_sort(words.begin(), words.end(), isShorter);
for (const auto &s : words) // no need to copy the strings
	cout << s << " "; // print each element separated by a space
cout << endl;

//10.3.2 Lambda Expressions

//The predicates we pass to an algorithm must have exactly one or two parameters, depending on whether the algorithm takes a unary or binary predicate, respectively. However, sometimes we want to do processing that requires more arguments than the algorithm’s predicate allows. For example, the solution you wrote for the last exercise in the previous section had to hard-wire the size 5 into the predicate used to partition the sequence. It would be move useful to be able to partition a sequence without having to write a separate predicate for every possible size.

//We can use the library find_if algorithm to find an element that has a particular size. Like find, the find_if algorithm takes a pair of iterators denoting a range. Unlike find, the third argument to find_if is a predicate. The find_if algorithm calls the given predicate on each element in the input range. It returns the first element for which the predicate returns a nonzero value, or its end iterator if no such element is found.

//It would be easy to write a function that takes a string and a size and returns a bool indicating whether the size of a given string is greater than the given size. However, find_if takes a unary predicate—any function we pass to find_if must have exactly one parameter that can be called with an element from the input sequence. There is no way to pass a second argument representing the size. To solve this part of our problem we’ll need to use some additional language facilities.

//Introducing Lambdas

//We can pass any kind of callable object to an algorithm. An object or expression is callable if we can apply the call operator to it. That is, if e is a callable expression, we can write e(args) where args is a comma-separated list of zero or more arguments.
//The only callables we’ve used so far are functions and function pointers. There are two other kinds of callables: classes that overload the function-call operator, which we’ll cover in § 14.8 (p. 571), and lambda expressions.
//A lambda expression represents a callable unit of code. It can be thought of as an unnamed, inline function. Like any function, a lambda has a return type, a parameter list, and a function body. Unlike a function, lambdas may be defined inside a function. A lamba expression has the form
[capture list] (parameter list) -> return type { function body }
//where capture list is an (often empty) list of local variables defined in the enclosing function; return type, parameter list, and function body are the same as in any ordinary function. However, unlike ordinary functions, a lambda must use a trailing return to specify its return type.

//We can omit either or both of the parameter list and return type but must always include the capture list and function body:
auto f = [] { return 42; };
//Here, we’ve defined f as a callable object that takes no arguments and returns 42.
//We call a lambda the same way we call a function by using the call operator:
cout << f() << endl; // prints 42
//Omitting the parentheses and the parameter list in a lambda is equivalent specifying an empty parameter list. Hence, when we call f, the argument list is empty. If we omit the return type, the lambda has an inferred return that depends on the code in the function body. If the function body is just a return statement, the return type is inferred from the type of the expression that is returned. Otherwise, the return type is void.

//Note: Lambdas with function bodies that contain anything other than a single return statement that do not specify a return type return void.

//Passing Arguments to a Lambda

//As with an ordinary function call, the arguments in a call to a lambda are used to initialize the lambda’s parameters. As usual, the argument and parameter types must match. Unlike ordinary functions, a lambda may not have default arguments. Therefore, a call to a lambda always has as many arguments as the lambda has parameters. Once the parameters are initialized, the function body executes.
//As an example of a lambda that takes arguments, we can write a lambda that behaves like our isShorter function:
[](const string &a, const string &b) { return a.size() < b.size();}

//The empty capture list indicates that this lambda will not use any local variables from the surrounding function. The lambda’s parameters, like the parameters to isShorter, are references to const string. Again like isShorter, the lambda’s function body compares its parameters’ size()s and returns a bool that depends on the relative sizes of the given arguments.
//We can rewrite our call to stable_sort to use this lambda as follows:
// sort words by size, but maintain alphabetical order for words of the same size
stable_sort(words.begin(), words.end(),
            [](const string &a, const string &b) { return a.size() < b.size();});
//When stable_sort needs to compare two elements, it will call the given lambda expression.

//Using the Capture List

//We’re now ready to solve our original problem, which is to write a callable expression that we can pass to find_if. We want an expression that will compare the length of each string in the input sequence with the value of the sz parameter in the biggies function.
//Although a lambda may appear inside a function, it can use variables local to that function only if it specifies which variables it intends to use. A lambda specifies the variables it will use by including those local variables in its capture list. The capture list directs the lambda to include information needed to access those variables within the lambda itself.
//In this case, our lambda will capture sz and will have a single string parameter. The body of our lambda will compare the given string’s size with the captured value of sz:
[sz](const string &a) { return a.size() >= sz; };
//Inside the [] that begins a lambda we can provide a comma-separated list of names defined in the surrounding function.
//Because this lambda captures sz, the body of the lambda may use sz. The lambda does not capture words, and so has no access to that variable. Had we given our lambda an empty capture list, our code would not compile:
// error: sz not captured
[](const string &a) { return a.size() >= sz; };

//Note: A lambda may use a variable local to its surrounding function only if the lambda captures that variable in its capture list.

//Calling find_if

//Using this lambda, we can find the first element whose size is at least as big as sz:
// get an iterator to the first element whose size() is >= sz
auto wc = find_if(words.begin(), words.end(),
				  [sz](const string &a) { return a.size() >= sz; });
//The call to find_if returns an iterator to the first element that is at least as long as the given sz, or a copy of words.end() if no such element exists.

//The for_each Algorithm

//The last part of our problem is to print the elements in words that have length sz or greater. To do so, we’ll use the for_each algorithm. This algorithm takes a callable object and calls that object on each element in the input range:
// print words of the given size or longer, each one followed by a space
for_each(wc, words.end(), [](const string &s){cout << s << " ";});
cout << endl;
//The capture list in this lambda is empty, yet the body uses two names: its own parameter, named s, and cout.
//The capture list is empty, because we use the capture list only for (nonstatic) variables defined in the surrounding function. A lambda can use names that are defined outside the function in which the lambda appears. In this case, cout is not a name defined locally in biggies; that name is defined in the iostream header. So long as the iostream header is included in the scope in which biggies appears, our lambda can use cout.

//Note: The capture list is  used for local nonstatic variables only; lambdas can use local statics and variables declared outside the function directly.

//10.3.3 Lambda Captures and Returns

//When we define a lambda, the compiler generates a new (unnamed) class type that corresponds to that lambda. We’ll see how these classes are generated in § 14.8.1 (p. 572). For now, what’s useful to understand is that when we pass a lambda to a function, we are defining both a new type and an object of that type: The argument is an unnamed object of this compiler-generated class type. Similarly, when we use auto to define a variable initialized by a lambda, we are defining an object of the type generated from that lambda.
//By default, the class generated from a lambda contains a data member corresponding to the variables captured by the lambda. Like the data members of any class, the data members of a lambda are initialized when a lambda object is created.

//Capture by Value
//Similar to parameter passing, we can capture variables by value or by reference. Table below covers the various ways we can form a capture list. So far, our lambdas have captured variables by value. As with a parameter passed by value, it must be possible to copy such variables. Unlike parameters, the value of a captured variable is copied when the lambda is created, not when it is called:
void fcn1() {
	size_t v1 = 42;    //local variable
    //copies v1 into the callable object named f
    auto f = [v1] {return v1;};
    v1 = 0;
    auto j = f();    //j is 42; f stored a copy of v1 when we created it
}
//Because the value is copied when the lambda is created, subsequent changes to a captured variable have no effect on the corresponding value inside the lambda.

//Lambda Capture List
[];    //Empty capture list. The lambda may not use variables from the enclosing function. A lambda may use local variables only if it captures them;
[name];    //names is a comma-separated list of names local to the enclosing function. By default, variables in the capture list are copied. A name preceded by & is captured by reference;
[&];    //Implicit by reference capture list. Entities from the enclosing function used in the lambda body are used by reference;
[=];    //Implicit by value capture list. Entities from the enclosing function used in the lambda body are copied into the lambda body;
[&, identifier_list];    //identifier_list is a comma-separated list of zero or more variables from the enclosing function. These variables are captured by value; any implicitly captured variables are captured by reference. The name in identifier_list must not be preceded by an &;
[=, reference_list];    //Variables included in the reference_list are captured by reference; any implicitly captured variables are captured by value. The names in reference_list may not include this and must be preceded by an &;

//Capture by Reference

//We can also define lambdas that capture variables by reference. For example:
void fcn2() {
    size_t v1 = 42; // local variable
    // the object f2 contains a reference to v1
    auto f2 = [&v1] { return v1; };
    v1 = 0;
    auto j = f2(); // j is 0; f2 refers to v1; it doesn't store it
}
//The & before v1 indicates that v1 should be captured as a reference. A variable captured by reference acts like any other reference. When we use the variable inside the lambda body, we are using the object to which that reference is bound. In this case, when the lambda returns v1, it returns the value of the object to which v1 refers.
//Reference captures have the same problems and restrictions as reference returns. If we capture a variable by reference, we must be certain that the referenced object exists at the time the lambda is executed. The variables captured by a lambda are local variables. These variables cease to exist once the function completes. If it is possible for a lambda to be executed after the function finishes, the local variables to which the capture refers no longer exist.
//Reference captures are sometimes necessary. For example, we might want our biggies function to take a reference to an ostream on which to write and a character to use as the separator:
void biggies(vector<string> &words, vector<string>::size_type sz, ostream &os = cout, char c = ' ') {
	// code to reorder words as before
	// statement to print count revised to print to os
	for_each(words.begin(), words.end(), [&os, c](const string &s) { os << s << c; });
}
//We cannot copy ostream objects; the only way to capture os is by reference (or through a pointer to os).
//When we pass a lambda to a function, as in this call to for_each, the lambda executes immediately. Capturing os by reference is fine, because the variables in biggies exist while for_each is running.
//We can also return a lambda from a function. The function might directly return a callable object or the function might return an object of a class that has a callable object as a data member. If the function returns a lambda, then—for the same reasons that a function must not return a reference to a local variable—that lambda must not contain reference captures.

//Warning: When we capture a variable by reference, we must ensure that the variable exists at the time that the lambda executes.

//Advice: Keep Your Lambda Captures Simple
//A lambda capture stores information between the time the lambda is created (i.e., when the code that defines the lambda is executed) and the time (or times) the lambda itself is executed. It is the programmer’s responsibility to ensure that whatever information is captured has the intended meaning each time the lambda is executed.
//Capturing an ordinary variable—an int, a string, or other nonpointer type—by value is usually straightforward. In this case, we only need to care whether the variable has the value we need when we capture it.
//If we capture a pointer or iterator, or capture a variable by reference, we must ensure that the object bound to that iterator, pointer, or reference still exists, whenever the lambda executes. Moreover, we need to ensure that the object has the intended value. Code that executes between when the lambda is created and when it executes might change the value of the object to which the lambda capture points (or refers). The value of the object at the time the pointer (or reference) was captured might have been what we wanted. The value of that object when the lambda executes might be quite different.
//As a rule, we can avoid potential problems with captures by minimizing the data we capture. Moreover, if possible, avoid capturing pointers or references.

//Implicit Captures

//Rather than explicitly listing the variables we want to use from the enclosing function, we can let the compiler infer which variables we use from the code in the lambda’s body. To direct the compiler to infer the capture list, we use an & or = in the capture list. The & tells the compiler to capture by reference, and the = says the values are captured by value. For example, we can rewrite the lambda that we passed to find_if as
// sz implicitly captured by value
wc = find_if(words.begin(), words.end(), [=](const string &s)
{ return s.size() >= sz; });
//If we want to capture some variables by value and others by reference, we can mix implicit and explicit captures:
void biggies(vector<string> &words, vector<string>::size_type sz, ostream &os = cout, char c = ' ') {
    // other processing as before
	// os implicitly captured by reference; c explicitly captured by value
	for_each(words.begin(), words.end(), [&, c](const string &s) { os << s << c; });
	// os explicitly captured by reference; c implicitly captured by value
	for_each(words.begin(), words.end(), [=, &os](const string &s) { os << s << c; });
}
//When we mix implicit and explicit captures, the first item in the capture list must be an & or =. That symbol sets the default capture mode as by reference or by value, respectively.
//When we mix implicit and explicit captures, the explicitly captured variables must use the alternate form. That is, if the implicit capture is by reference (using &), then the explicitly named variables must be captured by value; hence their names may not be preceded by an &. Alternatively, if the implicit capture is by value (using =), then the explicitly named variables must be preceded by an & to indicate that they are to be captured by reference.

//Mutable Lambdas

//By default, a lambda may not change the value of a variable that it copies by value. If we want to be able to change the value of a captured variable, we must follow the parameter list with the keyword mutable. Lambdas that are mutable may not omit the parameter list:
void fcn3() {
	size_t v1 = 42; // local variable
	// f can change the value of the variables it captures
	auto f = [v1] () mutable { return ++v1; };
	v1 = 0;
	auto j = f(); // j is 43
}

//Whether a variable captured by reference can be changed (as usual) depends only on whether that reference refers to a const or nonconst type:
void fcn4() {
	size_t v1 = 42; // local variable
	// v1 is a reference to a non const variable
	// we can change that variable through the reference inside f2
	auto f2 = [&v1] { return ++v1; };
	v1 = 0;
	auto j = f2(); // j is 1
}

//Specifying the Lambda Return Type

//The lambdas we’ve written so far contain only a single return statement. As a result, we haven’t had to specify the return type. By default, if a lambda body contains any statements other than a return, that lambda is assumed to return void. Like other functions that return void, lambdas inferred to return void may not return a value.
//As a simple example, we might use the library transform algorithm and a lambda to replace each negative value in a sequence with its absolute value:

transform(vi.begin(), vi.end(), vi.begin(), [](int i) { return i < 0 ? -i : i; });
//The transform function takes three iterators and a callable. The first two iterators denote an input sequence and the third is a destination. The algorithm calls the given callable on each element in the input sequence and writes the result to the destination. As in this call, the destination iterator can be the same as the iterator denoting the start of the input. When the input iterator and the destination iterator are the same, transform replaces each element in the input range with the result of calling the callable on that element.
//In this call, we passed a lambda that returns the absolute value of its parameter. The lambda body is a single return statement that returns the result of a conditional expression. We need not specify the return type, because that type can be inferred from the type of the conditional operator.
//However, if we write the seemingly equivalent program using an if statement, our code won’t compile:
// error: cannot deduce the return type for the lambda
transform(vi.begin(), vi.end(), vi.begin(), [](int i) { if (i < 0) return -i; else return i; });
//This version of our lambda infers the return type as void but we returned a value.
//When we need to define a return type for a lambda, we must use a trailing return type:
transform(vi.begin(), vi.end(), vi.begin(), [](int i) -> int
{ if (i < 0) return -i; else return i; });
//In this case, the fourth argument to transform is a lambda with an empty capture list, which takes a single parameter of type int and returns a value of type int. Its function body is an if statement that returns the absolute value of its parameter.

//10.3.4 Binding Arguments

//Lambda expressions are most useful for simple operations that we do not need to use in more than one or two places. If we need to do the same operation in many places, we should usually define a function rather than writing the same lambda expression multiple times. Similarly, if an operation requires many statements, it is ordinarily better to use a function.
//It is usually straightforward to use a function in place of a lambda that has an empty capture list. As we’ve seen, we can use either a lambda or our isShorter function to order the vector on word length. Similarly, it would be easy to replace the lambda that printed the contents of our vector by writing a function that takes a string and prints the given string to the standard output.
//However, it is not so easy to write a function to replace a lambda that captures local variables. For example, the lambda that we used in the call to find_if compared a string with a given size. We can easily write a function do to the same work:
bool check_size(const string &s, string::size_type sz){
	return s.size() >= sz;
}

//However, we can't use this function as an argument to find_if. As we've seen, find_if takes a unary predicate, so the callable passed to find_if must make a single argument. The lambda that the biggies passed to find_if used its capture list to store sz. In order to use check_size in place of that lambda, we have to figure out how to pass an argument to the sz parameter.

//The Library bind Function

//We can solve the problem of passing a size argument to check_size by using a new library function named bind, which is defined in the functional header. The bind function can be thought of as a general-purpose function adaptor. It takes a callable object and generates a new callable that "adapts" the parameter list of the original object.

//The general form of a call to bind is:
auto newCallable = bind(callable, arg_list);
//where newCallable is itself a callable object and arg_list is a comma-separated list of arguments that correspond to the parameters of the given callable. That is, when we call newCallable, newCallable calls callable, passing the arguments in arg_list.
//The arguments in arg_list may include names of the form _n, where n is an integer. These arguments are “placeholders” representing the parameters of newCallable. They stand “in place of” the arguments that will be passed to newCallable. The number n is the position of the parameter in the generated callable: _1 is the first parameter in newCallable, _2 is the second, and so forth.

//Binding the sz Parameter of check_size

//As a simple example, we'll use bind to generate an object that calls check_size with a fixed value for its size parameter as follows:
//check6 is a callable object that takes one argument of type string and calls check_size on its given string and the value 6
auto check6 = bind(check_size, _1, 6); 
//This call to bind has only one placeholder, which means that check6 takes a single argument. The placeholder appears first in arg_list, which means that the parameter in check6 corresponds to the first parameter of check_size. That parameter is a const string&, which means that the parameter in check6 is also a const string&. Thus, a call to check6 must pass an argument of type string, which check6 will pass as the first argument to check_size.
//The second argument in arg_list (i.e., the third argument to bind) is the value 6. That value is bound to the second parameter of check_size. Whenever we call check6, it will pass 6 as the second argument to check_size:
string s = "hello";
bool b1 = check6(s); // check6(s) calls check_size(s, 6)
//Using bind, we can replace our original lambda-based call to find_if
auto wc = find_if(words.begin(), words.end(), [sz](const string &a) {});
//with a version that use check_size:
auto wc = find_if(words.begin(), words.end(), bind(check_size, _1, sz));
//This call to bind generates a callable object that binds the second argument of check_size to the value of sz. When find_if calls this object on the strings in words those calls will in turn call check_size passing the given string and sz. So, find_if (effectively) will call check_size on each string in the input range and compare the size of that string to sz.

//Using placeholders Names

//The _n names are defined in a namespace named placeholders. That namespace is itself defined inside the std namespace. To use these names, we must supply the names of both namespaces. As with our other examples, our calls to bind assume the existence of appropriate using declarations. For example, the using declaration for _1 is
using std::placeholders::_1;
//This declaration says we’re using the name _1, which is defined in the namespace placeholders, which is itself defined in the namespace std. 
//We must provide a separate using declaration for each placeholder name that we use. Writing such declarations can be tedious and error-prone. Rather than separately declaring each placeholder, we can use a different form of using that we will cover in more detail in § 18.2.2 (p. 793). This form:
using namespace namespace_name;
//says that we want to make all the names from namespace_name accessible to our program. For example:
using namespace std::placeholders;
//makes all the names defined by placeholders usable. Like the bind function, the placeholders namespace is defined in the functional header.

//Arguments to bind
//As we’ve seen, we can use bind to fix the value of a parameter. More generally, we can use bind to bind or rearrange the parameters in the given callable. For example, assuming f is a callable object that has five parameters, the following call to bind:
// g is a callable object that takes two arguments
auto g = bind(f, a, b, _2, c, _1);
//generates a new callable that takes two arguments, represented by the placeholders _2 and _1. The new callable will pass its own arguments as the third and fifth arguments to f. The first, second, and fourth arguments to f are bound to the given values, a, b, and c, respectively.
//The arguments to g are bound positionally to the placeholders. That is, the first argument to g is bound to _1, and the second argument is bound to _2. Thus, when we call g, the first argument to g will be passed as the last argument to f; the second argument to g will be passed as g’s third argument. In effect, this call to bind maps
g(_1, _2)
//to
f(a, b, _2, c, _1)
//That is, calling g calls f using g’s arguments for the placeholders along with the bound arguments, a, b, and c. For example, calling g(X, Y) calls
f(a, b, Y, c, X)

//Using to bind to Reorder Parameters
//As a more concrete example of using bind to reorder arguments, we can use bind to invert the meaning of isShorter by writing
// sort on word length, shortest to longest
sort(words.begin(), words.end(), isShorter);
// sort on word length, longest to shortest
sort(words.begin(), words.end(), bind(isShorter, _2, _1));
//In the first call, when sort needs to compare two elements, A and B, it will call isShorter(A, B). In the second call to sort, the arguments to isShorter are swapped. In this case, when sort compares elements, it will be as if sort called isShorter(B, A).

//Binding Reference Parameters
//By default, the arguments to bind that are not placeholders are copied into the callable object that bind returns. However, as with lambdas, sometimes we have arguments that we want to bind but that we want to pass by reference or we might want to bind an argument that has a type that we cannot copy.
//For example, to replace the lambda that captured an ostream by reference:
// os is a local variable referring to an output stream, c is a local variable of type char
for_each(words.begin(), words.end(), [&os, c](const string &s) { os << s << c; });
//We can easily write a function to do the same job:
ostream &print(ostream &os, const string &s, char c) {
	return os << s << c;
}
//However, we can’t use bind directly to replace the capture of os:
// error: cannot copy os
for_each(words.begin(), words.end(), bind(print, os, _1, ' '));
//because bind copies its arguments and we cannot copy an ostream. If we want to pass an object to bind without copying it, we must use the library ref function:
for_each(words.begin(), words.end(), bind(print, ref(os), _1, ' '));
//The ref function returns an object that contains the given reference and that is itself copyable. There is also a cref function that generates a class that holds a reference to const. Like bind, the ref and cref functions are defined in the functional header.

//Backward Compatibility: Binding Arguments
//Older versions of C++ provided a much more limited, yet more complicated, set of facilities to bind arguments to functions. The library defined two functions named bind1st and bind2nd. Like bind, these functions take a function and generate a new callable object that calls the given function with one of its parameters bound to a given value. However, these functions can bind only the first or second parameter, respectively. Because they are of much more limited utility, they have been deprecated in the new standard. A deprecated feature is one that may not be supported in future releases. Modern C++ programs should use bind.

//10.4 Revisiting Iterators

//In addition to the iterators that are defined for each of the containers, the library defines several additional kinds of iterators in the iterator header. These iterators include
//• Insert iterators: These iterators are bound to a container and can be used to insert elements into the container.
//• Stream iterators: These iterators are bound to input or output streams and can be used to iterate through the associated IO stream.
//• Reverse iterators: These iterators move backward, rather than forward. The library containers, other than forward_list, have reverse iterators.
//• Move iterators: These special-purpose iterators move rather than copy their elements. We’ll cover move iterators in § 13.6.2 (p. 543).

//10.4.1 Insert Iterators

//An inserter is an iterator adaptor that takes a container and yields an iterator that adds elements to the specified container. When we assign a value through an insert iterator, the iterator calls a container operation to add an element at a specified position in the given container. The operations these iterators support are
//Insert Iterator Operations
it = t;    //Inserts the value t at the current position denoted by it. Depending on the kind of insert iterator, and assuming c is the container to which t is bound, calls c.push_back(t), c.push_front(t), or c.insert(t, p), where p is the iterator position given to inserter;
*it, ++it, --it;    //These operations exist but do nothing to it. Each operator returns it;

//There are three kinds of inserters. Each differs from the others as to where elements are inserted:
//• back_inserter creates an iterator that uses push_back.
//• front_inserter creates an iterator that uses push_front.
//• inserter creates an iterator that uses insert. This function takes a second argument, which must be an iterator into the given container. Elements are inserted ahead of the element denoted by the given iterator.

//Note: We can use front_inserter only if the container has push_front. Similarly, we can use back_inserter only if it has push_back.

//It is important to understand that when we call inserter(c, iter), we get an iterator that, when used successively, inserts elements ahead of the element originally denoted by iter. That is, if it is an iterator generated by inserter, then an assignment such as
* it = va1;
//behaves as
it = c.insert(it, val); // it points to the newly added element
++it; // increment it so that it denotes the same element as before

//The iterator generated by front_inserter behaves quite differently from the one created by inserter. When we use front_inserter, elements are always inserted ahead of the then first element in the container. Even if the position we pass to inserter initially denotes the first element, as soon as we insert an element in front of that element, that element is no longer the one at the beginning of the container:
list<int> 1st = {1,2,3,4};
list<int> lst2, lst3; // empty lists
// after copy completes, 1st2 contains 4 3 2 1
copy(1st.cbegin(), lst.cend(), front_inserter(lst2));
// after copy completes, 1st3 contains 1 2 3 4
copy(1st.cbegin(), lst.cend(), inserter(lst3, lst3.begin()));
//When we call front_inserter(c), we get an insert iterator that successively calls push_front. As each element is inserted, it becomes the new first element in c. Therefore, front_inserter yields an iterator that reverses the order of the sequence that it inserts; inserter and back_inserter don’t.

//10.4.2 iostream Iterators

//Even though the iostream types are not containers, there are iterators that can be used with objects of the IO types. An istream_iterator reads an input stream, and an ostream_iterator writes an output stream. These iterators treat their corresponding stream as a sequence of elements of a specified type. Using a stream iterator, we can use the generic algorithms to read data from or write data to stream objects.
//istream_iterator Operations
istream_iterator<T> in(is);    //in reads values of type T from input stream is;
istream_iterator<T> end;    //Off-the-end iterator for an istream_iterator that reads values of type T;
in1 == in2;    //in1 and in2 must read the same type. They are equal if they are both the end value or are bound to the same input stream;
in1 != in2;
*in;    //Returns the value read from the stream;
in->mem;    //Synonym for (*in).mem;
++in, in++;    //Reads the next value from the input stream using the >> operator for the element type. As usual, the prefix version returns a reference to the incremented iterator. The postfix version returns the old value;

//ostream Iterator Operations
ostream_iterator<T> out(os);    //out writes values of type T to output stream os;
ostream_iterator<T> out(os, d);    //out writes values of type T followed by d to output stream os. d points to a null-terminated character array;
out = val;    //Writes val to the ostream to which out is bound using the << operator. val must have a type that is compatible with the type that out can write;
*out, **out, out++;    //These operations exist but do nothing to out. Each operator returns out;

//Operationss on istream_iterators

//When we create a stream iterator, we must specify the type of objects that the iterator will read or write. An istream_iterator uses >> to read a stream. Therefore, the type that an istream_iterator reads must have an input operator defined. When we create an istream_iterator, we can bind it to a stream. Alternatively, we can default initialize the iterator, which creates an iterator that we can use as the off-the-end value.
istream_iterator<int> int_it(cin); // reads ints from cin
istream_iterator<int> int_eof; // end iterator value
ifstream in("afile");
istream_iterator<string> str_it(in); // reads strings from "afile"
//As an example, we can use an istream_iterator to read the standard input into a vector:
istream_iterator<int> in_iter(cin); // read ints from cin
istream_iterator<int> eof; // istream ''end'' iterator
while (in_iter != eof) // while there's valid input to read
	// postfix increment reads the stream and returns the old value of the iterator
	// we dereference that iterator to get the previous value read from the stream
	vec.push_back(*in_iter++);
//This loop reads ints from cin, storing what was read in vec. On each iteration, the loop checks whether in_iter is the same as eof. That iterator was defined as the empty istream_iterator, which is used as the end iterator. An iterator bound to a stream is equal to the end iterator once its associated stream hits end-of-file or encounters an IO error.
//The hardest part of this program is the argument to push_back, which uses the dereference and postfix increment operators. This expression works just like others we’ve written that combined dereference with postfix increment (§ 4.5, p. 148). The postfix increment advances the stream by reading the next value but returns the old value of the iterator. That old value contains the previous value read from the stream. We dereference that iterator to obtain that value.
//What is more useful is that we can rewrite this program as
istream_iterator<int> in_iter(cin), eof; // read ints from cin
vector<int> vec(in_iter, eof); // construct vec from an iterator range
//Here we construct vec from a pair of iterators that denote a range of elements. Those iterators are istream_iterators, which means that the range is obtained by reading the associated stream. This constructor reads cin until it hits end-of-file or encounters an input that is not an int. The elements that are read are used to construct vec.

//Using Stream Iterators with the Algorithms
//Because algorithms operate in terms of iterator operations, and the stream iterators support at least some iterator operations, we can use stream iterators with at least some of the algorithms. We’ll see in § 10.5.1 (p. 410) how to tell which algorithms can be used with the stream iterators. As one example, we can call accumulate with a pair of istream_iterators:
istream_iterator<int> in(cin), eof;
cout << accumulate(in, eof, 0) << endl;
//This call will generate the sum of values read from the standard input.

//istream_iterators Are Permitted to Use Lazy Evaluation
//When we bind an istream_iterator to a stream, we are not guaranteed that it will read the stream immediately. The implementation is permitted to delay reading the stream until we use the iterator. We are guaranteed that before we dereference the iterator for the first time, the stream will have been read. For most programs, whether the read is immediate or delayed makes no difference. However, if we create an istream_iterator that we destroy without using or if we are synchronizing reads to the same stream from two different objects, then we might care a great deal when the read happens.

//Operations on ostream_iterators
//An ostream_iterator can be defined for any type that has an output operator (the << operator). When we create an ostream_iterator, we may (optionally) provide a second argument that specifies a character string to print following each element. That string must be a C-style character string (i.e., a string literal or a pointer to a null-terminated array). We must bind an ostream_iterator to a specific stream. There is no empty or off-the-end ostream_iterator.
//We can use an ostream_iterator to write a sequence of values:
ostream_iterator<int> out_iter(cout, " ");
for (auto e : vec)
    *out_iter++ = e; // the assignment writes this element to cout
cout << endl;
//This program writes each element from vec onto cout following each element with a space. Each time we assign a value to out_iter, the write is committed.
//It is worth noting that we can omit the dereference and the increment when we assign to out_iter. That is, we can write this loop equivalently as
for (auto e : vec)
    out_iter = e; // the assignment writes this element to cout
cout << endl;
//The * and ++ operators do nothing on an ostream_iterator, so omitting them has no effect on our program. However, we prefer to write the loop as first presented. That loop uses the iterator consistently with how we use other iterator types. We can easily change this loop to execute on another iterator type. Moreover, the behavior of this loop will be clearer to readers of our code.
//Rather than writing the loop ourselves, we can more easily print the elements in vec by calling copy:
copy(vec.begin(), vec.end(), out_iter);
cout << endl;

//Using Stream Iterators with Class Types
//We can create an istream_iterator for any type that has an input operator (>>). Similarly, we can define an ostream_iterator so long as the type has an output operator (<<). Because Sales_item has both input and output operators, we can use IO iterators to rewrite the bookstore program from § 1.6 (p. 24):
istream_iterator<Sales_item> item_iter(cin), eof;
ostream_iterator<Sales_item> out_iter(cout, "\n");
// store the first transaction in sum and read the next record
Sales_item sum = *item_iter++;
while (item_iter != eof) {
	// if the current transaction (which is stored in item_iter) has the same ISBN
	if (item_iter->isbn() == sum.isbn())
		sum += *item_iter++; // add it to sum and read the next transaction
	else {
		out_iter = sum; // write the current sum
		sum = *item_iter++; // read the next transaction
	}
}
out_iter = sum; // remember to print the last set of records

//Exercise10.33
//  Write a program that takes the names of an input file and two output files.
//  The input file should hold integers. Using an istream_iterator read the input file.
//  Using ostream_iterators, write the odd numbers into the first output file.
//  Each value should be followed by a space.Write the even numbers into the second file.
//  Each of these values should be placed on a separate line.
//
//  Run: ./a.out "../data/input.txt" "../data/odd.txt" "../data/even.txt"

#include <fstream>
#include <iterator>
#include <algorithm>

int main(int argc, char **argv)
{
    if (argc != 4) return -1;

    std::ifstream ifs(argv[1]);
    std::ofstream ofs_odd(argv[2]), ofs_even(argv[3]);

    std::istream_iterator<int> in(ifs), in_eof;
    std::ostream_iterator<int> out_odd(ofs_odd, " "), out_even(ofs_even, "\n");

    std::for_each(in, in_eof, [&out_odd, &out_even](const int i){
        *(i & 0x1 ? out_odd : out_even)++ = i;
    });

    return 0;
}

//10.4.3 Reverse Iterators

//A reverse iterator is an iterator that traverses a container backward, from the last element toward the first. A reverse iterator inverts the meaning of increment (and decrement). Incrementing (++it) a reverse iterator moves the iterator to the previous element; derementing (--it) moves the iterator to the next element.
//The containers, aside from forward_list, all have reverse iterators. We obtain a reverse iterator by calling the rbegin, rend, crbegin, and crend members. These members return reverse iterators to the last element in the container and one “past” (i.e., one before) the beginning of the container. As with ordinary iterators, there are both const and nonconst reverse iterators.
//Although it may seem confusing to have the meaning of the increment and decrement operators reversed, doing so lets us use the algorithms transparently to process a container forward or backward. For example, we can sort our vector in descending order by passing sort a pair of reverse iterators:
sort(vec.begin(), vec.end()); // sorts vec in ''normal'' order
// sorts in reverse: puts the smallest element at the end of vec
sort(vec.rbegin(), vec.rend());

//Reverse Iterators Require Decrement Operators
//Not surprisingly, we can define a reverse iterator only from an iterator that supports -- as well as ++. After all, the purpose of a reverse iterator is to move the iterator backward through the sequence. Aside from forward_list, the iterators on the standard containers all support decrement as well as increment. However, the stream iterators do not, because it is not possible to move backward through a stream. Therefore, it is not possible to create a reverse iterator from a forward_list or a stream iterator.

//Relationship between Reverse Iterators and Other Iterators
//Technically speaking, the relationship between normal and reverse iterators accommodates the properties of a left-inclusive range. The point is that [line.crbegin(), rcomma) and [rcomma.base(), line.cend()) refer to the same elements in line. In order for that to happen, rcomma and rcomma.base() must yield adjacent positions, rather than the same position, as must crbegin() and cend().

//Note: The fact that reverse iterators are intended to represent ranges and that these ranges are asymmetric has an important consequence: When we initialize or assign a reverse iterator from a plain iterator, the resulting iterator does not refer to the same element as the original.

//10.5 Structure of Generic Algorithms

//The most fundamental property of any algorithm is the list of operations it requires from its iterator(s). Some algorithms, such as find, require only the ability to access an element through the iterator, to increment the iterator, and to compare two iterators for equality. Others, such as sort, require the ability to read, write, and randomly access elements. The iterator operations required by the algorithms are grouped into five iterator categories listed in Table below. Each algorithm specifies what kind of iterator must be supplied for each of its iterator parameters.

//Iterator Categories
Input iterator;    //Read, but not write; single-pass, increment only;
Output iterator;    //Write, but not read; single-pass, increment only;
Forward iterator;    //Read and Write; multi-pass, increment only;
Bidirectional iterator;    //Read and write; multi-pass, increment and decrement;
Random-access iterator;    //Read and write; multi-pass, full iterator arithmetic;

//A second way is to classify the algorithms (as we did in the beginning of this chapter) is by whether they read, write, or reorder the elements in the sequence. Appendix A covers all the algorithms according to this classification.
//The algorithms also share a set of parameter-passing conventions and a set of naming conventions, which we shall cover after looking at iterator categories.

//10.5.1 The Five Iterator Categories

//Like the containers, iterators define a common set of operations. Some operations are provided by all iterators; other operations are supported by only specific kinds of iterators. For example, ostream_iterators have only increment, dereference, and assignment. Iterators on vector, strings, and deques support these operations and the decrement, relational, and arithmetic operators.
//Iterators are categorized by the operations they provide and the categories form a sort of hierarchy. With the exception of output iterators, an iterator of a higher category provides all the operations of the iterators of a lower categories.
//The standard specifies the minimum category for each iterator parameter of the generic and numeric algorithms. For example, find—which implements a one-pass, read-only traversal over a sequence—minimally requires an input iterator. The replace function requires a pair of iterators that are at least forward iterators. Similarly, replace_copy requires forward iterators for its first two iterators. Its third iterator, which represents a destination, must be at least an output iterator, and so on. For each parameter, the iterator must be at least as powerful as the stipulated minimum. Passing an iterator of a lesser power is an error.
//Warning: Many compilers will not complain when we pass the wrong category of iterator to an algorithm.

//The Iterator Categories
//Input iterators: can read elements in a sequence. An input iterator must provide
//• Equality and inequality operators (==, !=) to compare two iterators
//• Prefix and postfix increment (++) to advance the iterator
//• Dereference operator (*) to read an element; dereference may appear only on the right-hand side of an assignment
//• The arrow operator (->) as a synonym for (* it).member—that is, dereference the iterator and fetch a member from the underlying object
//Input iterators may be used only sequentially. We are guaranteed that *it++ is valid, but incrementing an input iterator may invalidate all other iterators into the stream. As a result, there is no guarantee that we can save the state of an input iterator and examine an element through that saved iterator. Input iterators, therefore, may be used only for single-pass algorithms. The find and accumulate algorithms require input iterators; istream_iterators are input iterators.

//Output iterators: can be thought of as having complementary functionality to input iterators; they write rather than read elements. Output iterators must provide
//• Prefix and postfix increment (++) to advance the iterator
//• Dereference (*), which may appear only as the left-hand side of an assignment (Assigning to a dereferenced output iterator writes to the underlying element.)
//We may assign to a given value of an output iterator only once. Like input iterators, output iterators may be used only for single-pass algorithms. Iterators used as a destination are typically output iterators. For example, the third parameter to copy is an output iterator. The ostream_iterator type is an output iterator.

//Forward iterators: can read and write a given sequence. They move in only one direction through the sequence. Forward iterators support all the operations of both input iterators and output iterators. Moreover, they can read or write the same element multiple times. Therefore, we can use the saved state of a forward iterator. Hence, algorithms that use forward iterators may make multiple passes through the sequence. The replace algorithm requires a forward iterator; iterators on forward_list are forward iterators.

//Bidirectional iterators: can read and write a sequence forward or backward. In addition to supporting all the operations of a forward iterator, a bidirectional iterator also supports the prefix and postfix decrement (--) operators. The reverse algorithm requires bidirectional iterators, and aside from forward_list, the library containers supply iterators that meet the requirements for a bidirectional iterator.

//Random-access iterators: provide constant-time access to any position in the sequence. These iterators support all the functionality of bidirectional iterators. In addition, random-access iterators support the operations from Table 3.7 (p. 111):
//• The relational operators (<, <=, >, and >=) to compare the relative positions of two iterators.
//• Addition and subtraction operators (+, +=, -, and -=) on an iterator and an integral value. The result is the iterator advanced (or retreated) the integral number of elements within the sequence.
//• The subtraction operator (-) when applied to two iterators, which yields the distance between two iterators.
//• The subscript operator (iter[n]) as a synonym for * (iter + n).
//The sort algorithms require random-access iterators. Iterators for array, deque, string, and vector are random-access iterators, as are pointers when used to access elements of a built-in array.

//10.5.2 Algorithm Parameter Patterns

//Superimposed on any other classification of the algorithms is a set of parameter conventions. Understanding these parameter conventions can aid in learning new algorithms—by knowing what the parameters mean, you can concentrate on understanding the operation the algorithm performs. Most of the algorithms have one of the following four forms:
alg(beg, end, other args);
alg(beg, end, dest, other args);
alg(beg, end, beg2, other args);
alg(beg, end, beg2, end2, other args);
//where alg is the name of the algorithm, and beg and end denote the input range on which the algorithm operates. Although nearly all algorithms take an input range, the presence of the other parameters depends on the work being performed. The common ones listed here—dest, beg2, and end2—are all iterators. When used, these iterators fill similar roles. In addition to these iterator parameters, some algorithms take additional, noniterator parameters that are algorithm specific.

//Algorithms with a Single Destination Iterator
//A dest parameter is an iterator that denotes a destination in which the algorithm can write its output. Algorithms assume that it is safe to write as many elements as needed.
//Warning: Algorithms that write to an output iterator assume the destination is large enough to hold the output.
//If dest is an iterator that refers directly to a container, then the algorithm writes its output to existing elements within the container. More commonly, dest is bound to an insert iterator or an ostream_iterator. An insert iterator adds new elements to the container, thereby ensuring that there is enough space. An ostream_iterator writes to an output stream, again presenting no problem regardless of how many elements are written.

//Algorithms with a Second Input Sequence
//Algorithms that take either beg2 alone or beg2 and end2 use those iterators to denote a second input range. These algorithms typically use the elements from the second range in combination with the input range to perform a computation. When an algorithm takes both beg2 and end2, these iterators denote a second range. Such algorithms take two completely specified ranges: the input range denoted by [beg, end), and a second input range denoted by [beg2, end2).
//Algorithms that take only beg2 (and not end2) treat beg2 as the first element in a second input range. The end of this range is not specified. Instead, these algorithms assume that the range starting at beg2 is at least as large as the one denoted by beg, end.
//Warning: Algorithms that take beg2 alone assume that the sequence beginning at beg2 is as large as the range denoted by beg and end.

//10.5.3 Algorithm Naming Conventions

//Separate from the parameter conventions, the algorithms also conform to a set of naming and overload conventions. These conventions deal with how we supply an operation to use in place of the default < or == operator and with whether the algorithm writes to its input sequence or to a separate destination.

//Some Algorithms Use Overloading to Pass a Predicate
//Algorithms that take a predicate to use in place of the < or == operator, and that do not take other arguments, typically are overloaded. One version of the function uses the element type’s operator to compare elements; the second takes an extra parameter that is a predicate to use in place of < or ==:
unique(beg, end); // uses the == operator to compare the elements
unique(beg, end, comp); // uses comp to compare the elements
//Both calls reorder the given sequence by removing adjacent duplicated elements. The first uses the element type’s == operator to check for duplicates; the second calls comp to decide whether two elements are equal. Because the two versions of the function differ as to the number of arguments, there is no possible ambiguity as to which function is being called.

//Algorithms with _if Versions
//Algorithms that take an element value typically have a second named (not overloaded) version that takes a predicate (§ 10.3.1, p. 386) in place of the value. The algorithms that take a predicate have the suffix _if appended:
find(beg, end, val); // find the first instance of val in the input range
find_if(beg, end, pred); // find the first instance for which pred is true
//These algorithms both find the first instance of a specific element in the input range. The find algorithm looks for a specific value; the find_if algorithm looks for a value for which pred returns a nonzero value.
//These algorithms provide a named version rather than an overloaded one because both versions of the algorithm take the same number of arguments. Overloading ambiguities would therefore be possible, albeit rare. To avoid any possible ambiguities, the library provides separate named versions for these algorithms.

//Distinguishing Versions That Copy from Those That Do Not
//By default, algorithms that rearrange elements write the rearranged elements back into the given input range. These algorithms provide a second version that writes to a specified output destination. As we’ve seen, algorithms that write to a destination append _copy to their names:
reverse(beg, end); // reverse the elements in the input range
reverse_copy(beg, end, dest);// copy elements in reverse order into dest
//Some algorithms provide both _copy and _if versions. These versions take a destination iterator and a predicate:
// removes the odd elements from v1
remove_if(v1.begin(), v1.end(),
[](int i) { return i % 2; });
// copies only the even elements from v1 into v2; v1 is unchanged
remove_copy_if(v1.begin(), v1.end(), back_inserter(v2),
[](int i) { return i % 2; });
//Both calls use a lambda to determine whether an element is odd. In the first case, we remove the odd elements from the input sequence itself. In the second, we copy the non-odd (aka even) elements from the input range into v2.

//10.6 Container-Specific Algorithms

//Unlike the other containers, list and forward_list define several algorithms as members. In particular, the list types define their own versions of sort, merge, remove, reverse, and unique. The generic version of sort requires randomaccess iterators. As a result, sort cannot be used with list and forward_list because these types offer bidirectional and forward iterators, respectively.
//The generic versions of the other algorithms that the list types define can be used with lists, but at a cost in performance. These algorithms swap elements in the input sequence. A list can “swap” its elements by changing the links among its elements rather than swapping the values of those elements. As a result, the list-specific versions of these algorithms can achieve much better performance than the corresponding generic versions.
//These list-specific operations are described in Table below. Generic algorithms not listed in the table that take appropriate iterators execute equally efficiently on lists and forward_listss as on other containers.

//Algorithms that are Members of list and forward_list
//These operations return void
lst.merge(lst2);    //Merge elements from lst2 ont lst. Both lst and lst2 must be sorted. Elements are removed from lst2. After the merge, lst2 is empty. The first version uses the < operator; the second version uses the given comparison operation;
lst.merge(lst2, comp);
lst.remove(val);    //Calls erase to remove each element that is == to the given value or for which the given unary predicate succeeds;
lst.remove_if(pred);
lst.reverse();    //Reverse the order of the elements in lst;
lst.sort();    //Sorts the element of lst using < or the given comparison operations;
lst.sort(comp);
lst.unique();    //Calls erase to remove consecutive copies of the same value. The first version uses ==; the second uses the given binary predicates;
lst.unique(pred);
//Best Practices: The list member versions should be used in preference to the generic algorithms for lists and forward_lists.

//The splice Members
//The list types also define a splice algorithm, which is described in Table below. This algorithm is particular to list data structures. Hence a generic version of this algorithm is not needed.
//Arguments to the list and forward_list splice Members
//lst.splice(args) or flst.splice_after(args)
(p, lst2);    //p is an iterator to an element in lst or an iterator just before an element in flst. Moves all the element(s) from lst2 into lst just before p or into flst just after p. Removes the element(s) from lst2. lst2 must have the same type as lst or flst and may not be the same list;
(p, lst2, p2);    //p2 is a valid iterator into lst2. Moves the element denoted by p2 into lst or moves the element just after p2 into flst. lst2 can be the same list as lst or flst;
(p, lst2, b, e);    //b and e must denote a valid range in lst2. Moves the elements in the given range from lst2. lst2 and lst (or flst) can be the same list but p must not denote an element in the given range;

//The List-Specific Operations Do Change the Containers
//Most of the list-specific algorithms are similar—but not identical—to their generic counterparts. However, a crucially important difference between the list-specific and the generic versions is that the list versions change the underlying container. For example, the list version of remove removes the indicated elements. The list version of unique removes the second and subsequent duplicate elements.
//Similarly, merge and splice are destructive on their arguments. For example, the generic version of merge writes the merged sequence to a given destination iterator; the two input sequences are unchanged. The list merge function destroys the given list—elements are removed from the argument list as they are merged into the object on which merge was called. After a merge, the elements from both lists continue to exist, but they are all elements of the same list.
