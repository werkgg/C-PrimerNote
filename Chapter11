//Chapter11 Associative Containers

//Associative and sequential containers differ from one another in a fundamental way: Elements in an associative container are stored and retrieved by a key. In contrast, elements in a sequential container are stored and accessed sequentially by their position in the container.
//Although the associative containers share much of the behavior of the sequential containers, they differ from the sequential containers in ways that reflect the use of keys.
//Associative containers support efficient lookup and retrieval by a key. The two primary associative-container types are map and set. The elements in a map are key–value pairs: The key serves as an index into the map, and the value represents the data associated with that index. A set element contains only a key; a set supports efficient queries as to whether a given key is present. We might use a set to hold words that we want to ignore during some kind of text processing. A dictionary would be a good use for a map: The word would be the key, and its definition would be the value.
//The library provides eight associative containers, listed in Table below. These eight differ along three dimensions: Each container is (1) a set or a map, (2) requires unique keys or allows multiple keys, and (3) stores the elements in order or not. The containers that allow multiple keys include the word multi; those that do not keep their keys ordered start with the word unordered. Hence an unordered_multi_set is a set that allows multiple keys whose elements are not stored in order, whereas a set has unique keys that are stored in order. The unordered containers use a hash function to organize their elements. We’ll have more to say about the hash function in § 11.4 (p. 444).
//Associative Container Types
//Elements Ordered by Key
map;    //Associative array; holds key-value pairs;
set;    //Container in which the key is the value; set is usually implemented by red-black tree;
multimap;    //map in which a key can appear multiple times;
multiset;    //set in which a key can appear multiple times;
//Unordered Collections
unordered_map;    //map organized by a hash function;
unordered_set;    //set organized by a hash function;
unordered_multimap;    //Hashed map; keys can appear multiple times;
unordered_multiset;    //Hashed set; keys can appear multiple times;
//The map and multimap types are defined in the map header; the set and multiset types are in the set header; and the unordered containers are in the unordered_map and unordered_set headers.

//11.1 Using an Associative Container

//Although most programmers are familiar with data structures such as vectors and lists, many have never used an associative data structure. Before we look at the details of how the library supports these types, it will be helpful to start with examples of how we can use these containers.
//A map is a collection of key–value pairs. For example, each pair might contain a person’s name as a key and a phone number as its value. We speak of such a data structure as “mapping names to phone numbers.” The map type is often referred to as an associative array. An associative array is like a “normal” array except that its subscripts don’t have to be integers. Values in a map are found by a key rather than by their position. Given a map of names to phone numbers, we’d use a person’s name as a subscript to fetch that person’s phone number.
//In contrast, a set is simply a collection of keys. A set is most useful when we simply want to know whether a value is present. For example, a business might define a set named bad_checks to hold the names of individuals who have written bad checks. Before accepting a check, that business would query bad_checks to see whether the customer’s name was present.

//Using a map
//A classic example that relies on associative arrays is a word-counting program:
// count the number of times each word occurs in the input
map<string, size_t> word_count; // empty map from string to size_t
string word;
while (cin >> word)
	++word_count[word]; // fetch and increment the counter for word
for (const auto &w : word_count) // for each element in the map
	// print the results
	cout << w.first << " occurs " << w.second << ((w.second > 1) ? " times" : " time") << endl;
//This program reads its input and reports how often each word appears.
//Like the sequential containers, the associative containers are templates To define a map, we must specify both the key and value types. In this program, the map stores elements in which the keys are strings and the values are size_ts. When we subscript word_count, we use a string as the subscript, and we get back the size_t counter associated with that string.
//The while loop reads the standard input one word at a time. It uses each word to subscript word_count. If word is not already in the map, the subscript operator creates a new element whose key is word and whose value is 0. Regardless of whether the element had to be created, we increment the value.
//Once we’ve read all the input, the range for (§ 3.2.3, p. 91) iterates through the map, printing each word and the corresponding counter. When we fetch an element from a map, we get an object of type pair, which we’ll describe in § 11.2.3 (p. 426).Briefly, a pair is a template type that holds two (public) data elements named first and second. The pairs used by map have a first member that is the key and a second member that is the corresponding value. Thus, the effect of the output statement is to print each word and its associated counter.

//Using a set
//A logical extension to our program is to ignore common words like “the,” “and,” “or,” and so on. We’ll use a set to hold the words we want to ignore and count only those words that are not in this set:
// count the number of times each word occurs in the input
map<string, size_t> word_count; // empty map from string to size_t
set<string> exclude = {"The", "But", "And", "Or", "An", "A", "the", "but", "and", "or", "an", "a"};
string word;
while (cin >> word)
	// count only words that are not in exclude
	if (exclude.find(word) == exclude.end())
		++word_count[word]; // fetch and increment the counter for word
//Like the other containers, set is a template. To define a set, we specify the type of its elements, which in this case are strings. As with the sequential containers, we can list initialize the elements of an associative container. Our exclude set holds the 12 words we want to ignore.
//The important difference between this program and the previous program is that before counting each word, we check whether the word is in the exclusion set. We do this check in the if:
// count only words that are not in exclude
if (exclude.find(word) == exclude.end())
//The call to find returns an iterator. If the given key is in the set, the iterator refers to that key. If the element is not found, find returns the off-the-end iterator. In this version, we update the counter for word only if word is not in exclude.

//11.2 Overview of the Associative Containers
//Associative containers (both ordered and unordered) support the general container operations covered in § 9.2 (p. 328) and listed in Table 9.2 (p. 330). The associative containers do not support the sequential-container position-specific operations, such as push_front or back. Because the elements are stored based on their keys, these operations would be meaningless for the associative containers. Moreover, the associative containers do not support the constructors or insert operations that take an element value and a count.
//In addition to the operations they share with the sequential containers, the associative containers provide some operations (Table 11.7 (p. 438)) and type aliases (Table 11.3 (p. 429)) that the sequential containers do not. In addition, the unordered containers provide operations for tuning their hash performance, which we’ll cover in § 11.4 (p. 444).
//The associative container iterators are bidirectional.

//11.2.1 Defining an Associative Container
//As we’ve just seen, when we define a map, we must indicate both the key and value type; when we define a set, we specify only a key type, because there is no value type. Each of the associative containers defines a default constructor, which creates an empty container of the specified type. We can also initialize an associative container as a copy of another container of the same type or from a range of values, so long as those values can be converted to the type of the container. Under the new standard, we can also list initialize the elements:
map<string, size_t> word_count; // empty
// list initialization
set<string> exclude = {"the", "but", "and", "or", "an", "a", "The", "But", "And", "Or", "An", "A"};
// three elements; authors maps last name to first
map<string, string> authors = { {"Joyce", "James"},
								{"Austen", "Jane"},
								{"Dickens", "Charles"} };
//As usual, the initializers must be convertible to the type in the container. For set, the element type is the key type.
//When we initialize a map, we have to supply both the key and the value. We wrap each key–value pair inside curly braces:
{key, value}
//to indicate that the items together form one element in the map. The key is the first element in each pair, and the value is the second. Thus, authors maps last names to first names, and is initialized with three elements.

//Initializing a multimap or multiset
//The keys in a map or a set must be unique; there can be only one element with a given key. The multimap and multiset containers have no such restriction; there can be several elements with the same key. For example, the map we used to count words must have only one element per given word. On the other hand, a dictionary could have several definitions associated with a particular word.

//11.2.2 Requirements on Key Type

//The associative containers place constraints on the type that is used as a key. We’ll cover the requirements for keys in the unordered containers in § 11.4 (p. 445). For the ordered containers—map, multimap, set, and multiset—the key type must define a way to compare the elements. By default, the library uses the < operator for the key type to compare the keys. In the set types, the key is the element type; in the map types, the key is the first type.

//Note: Callable objects passed to a sort algorithm must meet the same requirements as do the keys in an associative container.

//Key Types for Ordered Containers

//Just as we can provide our own comparison operation to an algorithm, we can also supply our own operation to use in place of the < operator on keys. The specified operation must define a strict weak ordering over the key type. We can think of a strict weak ordering as “less than,” although our function might use a more complicated procedure. However we define it, the comparison function must have the following properties:
//• Two keys cannot both be “less than” each other; if k1 is “less than” k2, then k2 must never be “less than” k1.
//• If k1 is “less than” k2 and k2 is “less than” k3, then k1 must be “less than” k3.
//• If there are two keys, and neither key is “less than” the other, then we’ll say that those keys are “equivalent.” If k1 is “equivalent” to k2 and k2 is “equivalent” to k3, then k1 must be “equivalent” to k3.
//If two keys are equivalent (i.e., if neither is “less than” the other), the container treats them as equal. When used as a key to a map, there will be only one element associated with those keys, and either key can be used to access the corresponding value.
//Note: In practice, what’s important is that a type that defines a < operator that “behaves normally” can be used as a key.

//Using a Comparison Function for the Key Type
//The type of the operation that a container uses to organize its elements is part of the type of that container. To specify our own operation, we must supply the type of that operation when we define the type of an associative container. The operation type is specified following the element type inside the angle brackets that we use to say which type of container we are defining.
//Each type inside the angle brackets is just that, a type. We supply a particular comparison operation (that must have the same type as we specified inside the angle brackets) as a constructor argument when we create a container.
//For example, we can’t directly define a multiset of Sales_data because Sales_data doesn’t have a < operator. However, we can use the compareIsbn function from the exercises in § 10.3.1 (p. 387) to define a multiset. That function defines a strict weak ordering based on their ISBNs of two given Sales_data objects. The compareIsbn function should look something like
bool compareIsbn(const Sales_data &lhs, const Sales_data &rhs) {
	return lhs.isbn() < rhs.isbn();
}
//To use our own operation, we must define the multiset with two types: the key type, Sales_data, and the comparison type, which is a function pointer type that can point to compareIsbn. When we define objects of this type, we supply a pointer to the operation we intend to use. In this case, we supply a pointer to compareIsbn:
// bookstore can have several transactions with the same ISBN, elements in bookstore will be in ISBN order
multiset<Sales_data, decltype(compareIsbn)*> bookstore(compareIsbn);
//Here, we use decltype to specify the type of our operation, remembering that when we use decltype to form a function pointer, we must add a * to indicate that we’re using a pointer to the given function type. We initialize bookstore from compareIsbn, which means that when we add elements to bookstore, those elements will be ordered by calling compareIsbn. That is, the elements in bookstore will be ordered by their ISBN members. We can write compareIsbn instead of &compareIsbn as the constructor argument because when we use the name of a function, it is automatically converted into a pointer if needed. We could have written &compareIsbn with the same effect.

//11.2.3 The pair Type

//pair is defined in the utility header. A pair holds two data members. Like the containers, pair is a template from which we generate specific types. We must supply two type names when we create a pair. The data members of the pair have the corresponding types. There is no requirement that the two types be the same.

//The default pair constructor value initializes the data members.

//Unlike other library types, the data members of pair are public. These members are named first and second, respectively. We access these members using the normal member access notation (§ 1.5.2, p. 23), as, for example, we did in the output statement of our word-counting program on page 421:
// print the results
cout << w.first << " occurs " << w.second << ((w.second > 1) ? " times" : " time") << endl;
//Here, w is a reference to an element in a map. Elements in a map are pairs. In this statement we print the first member of the element, which is the key, followed by the second member, which is the counter.

//Opeartions on pairs
pair<T1, T2> p;    //p is a pair with value initialized members of types T1 and T2, respectively;
pair<T1, T2> p(v1, v2);    //p is a pair with types T1 and T2; the first and second members are initialized from v1 and v2, respectively;
pair<T1, T2> p = {v1, v2};    //Equivalent to p(v1, v2);
make_pair(v1, v2);    //Returns a pair initialized from v1 and v2. The type of the pair is inferred from the types of v1 and v2;
p.first;    //Returns the (public) data member of p named first;
p.second;    //Returns the (public) data member of p named second;
p1 reloy p2;    //Relational operators (<, >, <=, >=). Relational operators are defined as dictionary ordering; For example, p1<p2 is true if p1.first<p2.first or if !(p2.first<p1.first)&&p1.second<p2.second. Uses the element's < operator;
p1 == p2;    //Two pairs are equal if their first and second members are respectively equal. Uses the element's == operator;
p1 != p2;

//A Function to Create pair Objects
//Imagine we have a function that needs to return a pair. Under the new standard we can list initialize the return value:
pair<string, int> process(vector<string> &v) {
	// process v
	if (!v.empty())
		return {v.back(), v.back().size()}; // list initialize
	else
		return pair<string, int>(); // explicitly constructed return value
}
//If v isn’t empty, we return a pair composed of the last string in v and the size of that string. Otherwise, we explicitly construct and return an empty pair.
//Under earlier versions of C++, we couldn’t use braced initializers to return a type like pair. Instead, we might have written both returns to explicitly construct the return value:
if (!v.empty())
	return pair<string, int>(v.back(), v.back().size());
//Alternatively, we could have used make_pair to generate a new pair of the appropriate type from its two arguments:
if (!v.empty())
	return make_pair(v.back(), v.back().size());

//11.3 Operations on Associative Containers

//Associative containers define the types listed in Table below. These types represent the container's key and value types.
//Associative Container Additional Types Aliases
key_type;    //Type of key for this container type;
mapped_type;    //Type associated with each key; map types only;
value_type;    //For sets, same as the key_type; For maps, pair<const key_type, mapped_type>;
//For the set types, the key_type and the value_type are the same; the values held in a set are the keys. In a map, the elements are key–value pairs. That is, each element is a pair object containing a key and a associated value. Because we cannot change an element’s key, the key part of these pairs is const:
set<string>::value_type v1; // v1 is a string
set<string>::key_type v2; // v2 is a string
map<string, int>::value_type v3; // v3 is a pair<const string, int>
map<string, int>::key_type v4; // v4 is a string
map<string, int>::mapped_type v5; // v5 is an int
//As with the sequential containers, we use the scope operator to fetch a type member—for example, map<string, int>::key_type.
//Only the map types (unordered_map, unordered_multimap, multimap, and map) define mapped_type.

//11.3.1 Associative Container Iterators
//When we dereference an iterator, we get a reference to a value of the container's value_type. In the case of map, the value_type is a pair in which first holds the const key and second holds the value:
// get an iterator to an element in word_count
auto map_it = word_count.begin();
// *map_it is a reference to a pair<const string, size_t> object
cout << map_it->first; // prints the key for this element
cout << " " << map_it->second; // prints the value of the element
map_it->first = "new key"; // error: key is const
++map_it->second; // ok: we can change the value through an iterator
//Note: It is essential to remember that the value_type of a map is a pair and that we can change the value but not the key member of that pair.

//Iterators for set are Const
//Although the set types define both the iterator and const_iterator types, both types of iterators give us read-only access to the elements in the set. Just as we cannot change the key part of a map element, the keys in a set are also const. We can use a set iterator to read, but not write, an element’s value:
set<int> iset = {0,1,2,3,4,5,6,7,8,9};
set<int>::iterator set_it = iset.begin();
if (set_it != iset.end()) {
	*set_it = 42; // error: keys in a set are read-only
	cout << *set_it << endl; // ok: can read the key
}

//Iterating across an Associative Container
//The map and set types provide all the begin and end operations from Table 9.2 (p. 330). As usual, we can use these functions to obtain iterators that we can use to traverse the container. For example, we can rewrite the loop that printed the results in our word-counting program on page 421 as follows:
// get an iterator positioned on the first element
auto map_it = word_count.cbegin();
// compare the current iterator to the off-the-end iterator
while (map_it != word_count.cend()) {
	// dereference the iterator to print the element key--value pairs
	cout << map_it->first << " occurs " << map_it->second << " times" << endl;
	++map_it; // increment the iterator to denote the next element
}
//Note: The output of this program is in alphabetical order. When we use an iterator to traverse a map, multimap, set, or multiset, the iterators yield elements in ascending key order.

//Associative Containers and Algorithms
//In general, we do not use the generic algorithms with the associative containers. The fact that the keys are const means that we cannot pass associative container iterators to algorithms that write to or reorder container elements. Such algorithms need to write to the elements. The elements in the set types are const, and those in maps are pairs whose first element is const.
//Associative containers can be used with the algorithms that read elements. However, many of these algorithms search the sequence. Because elements in an associative container can be found (quickly) by their key, it is almost always a bad idea to use a generic search algorithm. For example, as we’ll see in § 11.3.5 (p. 436), the associative containers define a member named find, which directly fetches the element with a given key. We could use the generic find algorithm to look for an element, but that algorithm does a sequential search. It is much faster to use the find member defined by the container than to call the generic version.
//In practice, if we do so at all, we use an associative container with the algorithms either as the source sequence or as a destination. For example, we might use the generic copy algorithm to copy the elements from an associative container into another sequence. Similarly, we can call inserter to bind an insert iterator to an associative container. Using inserter, we can use the associative container as a destination for another algorithm.

//11.3.2 Adding Elements
//The insert members add one element or a range of elements. Because map and set (and the corresponding unordered types) contain unique key, inserting an element that is already present has no effect:
vector<int> ivec = {2,4,6,8,2,4,6,8}; // ivec has eight elements
set<int> set2; // empty set
set2.insert(ivec.cbegin(), ivec.cend()); // set2 has four elements
set2.insert({1,3,5,7,1,3,5,7}); // set2 now has eight elements
//Associative Container insert Operations
c.insert(v);    //v value_type object; args are used to construct an element;
c.emplace(args);    //For map and set, the element is inserted (or constructed) only if an element with the given key is not already in c. Returns a pair containing an iterator referring to the element with the given key and a bool indicating whether the element was inserted. For multimap and multiset, insert (or constructs) the given element and returns an iterator to the new element;
c.insert(b, e);    //b and e are iterators that denote a range of c::value_type values;
c.insert(il);    //il is a braced list of such values. Returns void. For map and set, inserts the elements with key that are not already in c. For multimap and multiset inserts, each element in the range;
c.insert(p, v);    //Like insert(v) (or emplace(args)), but uses iterator p as a hint for where to begin the search for where the new element should be stored. Returns an iterator to the element with the given key;
c.emplace(p, args);
//The versions of insert that take a pair of iterators or an initializer list work similarly to the corresponding constructors—only the first element with a given key is inserted.

//Adding Elements to a map
//When we insert into a map, we must remember that the element type is a pair. Often, we don’t have a pair object that we want to insert. Instead, we create a pair in the argument list to insert:
// four ways to add word to word_count
word_count.insert({word, 1});
word_count.insert(make_pair(word, 1));
word_count.insert(pair<string, size_t>(word, 1));
word_count.insert(map<string, size_t>::value_type(word, 1));
//As we’ve seen, under the new standard the easiest way to create a pair is to use brace initialization inside the argument list. Alternatively, we can call make_pair or explicitly construct the pair. The argument in the last call to insert:
map<string, size_t>::value_type(s, 1)
//constructs a new object of the appropriate pair type to insert into the map.

//Testing the Return from insert
//The value returned by insert (or emplace) depends on the container type and the parameters. For the containers that have unique keys, the versions of insert and emplace that add a single element return a pair that lets us know whether the insertion happened. The first member of the pair is an iterator to the element with the given key; the second is a bool indicating whether that element was inserted, or was already there. If the key is already in the container, then insert does nothing, and the bool portion of the return value is false. If the key isn’t present, then the element is inserted and the bool is true.
//As an example, we’ll rewrite our word-counting program to use insert:
// more verbose way to count number of times each word occurs in the input
map<string, size_t> word_count; // empty map from string to size_t
string word;
while (cin >> word) {
	// inserts an element with key equal to word and value 1;
	// if word is already in word_count, insert does nothing
	auto ret = word_count.insert({word, 1});
	if (!ret.second) // word was already in word_count
		++ret.first->second; // increment the counter
}

//Unwinding the Syntax
//The statement that increments the counter in this version of word-counting program can be hard to understand. It will be easier to understand that expression by first parenthesizing it to reflect the precedence of the operator:
++((ret.first)->second); // equivalent expression
//Explaining this expression step by step:
//ret holds the value returned by insert, which is a pair.
//ret.first is the first member of that pair, which is a map iterator referring to the element with the given key.
//ret.first-> dereferences that iterator to fetch that element. Elements in the map are also pairs.
//ret.first->second is the value part of the map element pair.
//++ret.first->second increments that value.
//Putting it back together, the increment statement fetches the iterator for the element with the key word and increments the counter associated with the key we tried to insert.
//For readers using an older compiler or reading code that predates the new standard, declaring and initializing ret is also somewhat tricky:
pair<map<string, size_t>::iterator, bool> ret = word_count.insert(make_pair(word, 1));
//It should be easy to see that we’re defining a pair and that the second type of the pair is bool. The first type of that pair is a bit harder to understand. It is the iterator type defined by the map<string, size_t> type.

//Adding Elements to multiset or multimap
//Our word-counting program depends on the fact that a given key can occur only once. That way, there is only one counter associated with any given word. Sometimes, we want to be able to add additional elements with the same key. For example, we might want to map authors to titles of the books they have written. In this case, there might be multiple entries for each author, so we’d use a multimap rather than a map. Because keys in a multi container need not be unique, insert on these types always inserts an element:
multimap<string, string> authors;
// adds the first element with the key Barth, John
authors.insert({"Barth, John", "Sot-Weed Factor"});
// ok: adds the second element with the key Barth, John
authors.insert({"Barth, John", "Lost in the Funhouse"});
//For the containers that allow multiple keys, the insert operation that takes a single element returns an iterator to the new element. There is no need to return a bool, because insert always adds a new element in these types.

//11.3.3 Erasing Elements
//The associative containers define three versions of erase, which are described in Table below. As with the sequential containers, we can erase one element or a range of elements by passing erase an iterator or an iterator pair. These versions of erase are similar to the corresponding operations on sequential containers: The indicated element(s) are removed and the function returns void.
//Removing Elements from an Associative Container
c.erase(k);    //Removes every element with key k from c. Returns size_type indicating the number of elements removed;
c.erase(p);    //Removes the element denoted by the iterator p from c. p must refer to an actual element in c; it must not be equal to c.end(). Returns an iterator to the element after p or c.end() if p denotes the last element in c;
c.erase(b, e);    //Removes the elements in the range denoted by the iterator pair b, e. Returns e;
//The associative containers supply an additional erase operation that takes a key_type argument. This version removes all the elements, if any, with the given key and returns a count of how many elements were removed. We can use this version to remove a specific word from word_count before printing the results:
// erase on a key returns the number of elements removed
if (word_count.erase(removal_word))
	cout << "ok: " << removal_word << " removed\n";
else cout << "oops: " << removal_word << " not found!\n";
//For the containers with unique keys, the return from erase is always either zero or one. If the return value is zero, then the element we wanted to erase was not in the container.
//For types that allow multiple keys, the number of elements removed could be greater than one:
auto cnt = authors.erase("Barth, John");
//If authors is the multimap we created in § 11.3.2 (p. 434), then cnt will be 2.

//11.3.4 Subscripting a map
//The map and unordered_map containers provide the subscript operator and a corresponding at function, which are described in Table below. The set types do not support subscripting because there is no “value” associated with a key in a set. The elements are themselves keys, so the operation of “fetching the value associated with a key” is meaningless. We cannot subscript a multimap or an unordered_multimap because there may be more than one value associated with a given key.
//Subscript Operation for map and unordered_map
c[k];    //Returns the element with key k; if k is not in c, adds a new, value-initialized element with key k;
c.at(k);    //Checked access to the element with key k, throws an out_of_range exception if k is not in c;
//Like the other subscript operators we’ve used, the map subscript takes an index (that is, a key) and fetches the value associated with that key. However, unlike other subscript operators, if the key is not already present, a new element is created and inserted into the map for that key. The associated value is value initialized.
//For example, when we write
map <string, size_t> word_count; // empty map
// insert a value-initialized element with key Anna; then assign 1 to its value
word_count["Anna"] = 1;
//the following steps take place:
//• word_count is searched for the element whose key is Anna. The element is not found.
//• A new key-value pair is inserted into word_count. The key is a const string holding Anna. The value is value initialized, meaning in this case that the value is 0.
//• The newly inserted element is fetched and is given the value 1. Because the subscript operator might insert an element, we may use subscript only on a map that is not const.
//Note: Subscripting a map behaves quite differently from subscripting an array or vector: Using a key that is not already present adds an element with that key to the map.

//Using the Value Returned from a Subscript Operation
//Another way in which the map subscript differs from other subscript operators we’ve used is its return type. Ordinarily, the type returned by dereferencing an iterator and the type returned by the subscript operator are the same. Not so for maps: when we subscript a map, we get a mapped_type object; when we dereference a map iterator, we get a value_type object.
//In common with other subscripts, the map subscript operator returns an lvalue. Because the return is an lvalue, we can read or write the element:
cout << word_count["Anna"]; // fetch the element indexed by Anna; prints 1
++word_count["Anna"]; // fetch the element and add 1 to it
cout << word_count["Anna"]; // fetch the element and print it; prints 2
//Note: Unlike vector or string, the type returned by the map subscript operator differs from the type obtained by dereferencing a map iterator.
//The fact that the subscript operator adds an element if it is not already in the map allows us to write surprisingly succinct programs such as the loop inside our wordcounting program. On the other hand, sometimes we only want to know whether an element is present and do not want to add the element if it is not. In such cases, we must not use the subscript operator.

//11.3.5 Accessing Elements
//The associative containers provide various ways to find a given element, which are described in Table below. Which operation to use depends on what problem we are trying to solve. If all we care about is whether a particular element is in the container, it is probably best to use find. For the containers that can hold only unique keys, it probably doesn’t matter whether we use find or count. However, for the containers with multiple keys, count has to do more work: If the element is present, it still has to count how many elements have the same key. If we don’t need the count, it’s best to use find:
//Operations to Find Elements in an Associative Container
//lower_bound and upper_bound not valid for the unordered containers. Subscript and at operations only for map and unordered_map that are not const.
c.find(k);    //Returns an iterator to the (first) element with key k, or the off-the-end iterator if k is not in the container;
c.count(k);    //Returns the number of elements with key k. For the containers with unique keys, the result is always zero or one;
c.lower_bound(k);    //Returns an iterator to the first element with key not less than k;
c.upper_bound(k);    //Returns an iterator to the first element with key greater than k;
c.equal_range(k);    //Returns a pair of iterators denoting the element with key k. If k is not present, both members are c.end();

//Using find Instead of Subscript for maps
//For the map and unordered_map types, the subscript operator provides the simplest method of retrieving a value. However, as we’ve just seen, using a subscript has an important side effect: If that key is not already in the map, then subscript inserts an element with that key. Whether this behavior is correct depends on our expectations.
//Sometimes, we want to know if an element with a given key is present without changing the map. We cannot use the subscript operator to determine whether an element is present, because the subscript operator inserts a new element if the key is not already there. In such cases, we should use find.

//Finding Elements in a multimap or multiset
//Finding an element in an associative container that requires unique keys is a simple matter—the element is or is not in the container. For the containers that allow multiple keys, the process is more complicated: There may be many elements with the given key. When a multimap or multiset has multiple elements of a given key, those elements will be adjacent within the container.
//For example, given our map from author to titles, we might want to print all the books by a particular author. We can solve this problem in three different ways. The most obvious way uses find and count:
string search_item("Alain de Botton"); // author we'll look for
auto entries = authors.count(search_item); // number of elements
auto iter = authors.find(search_item); // first entry for this author
// loop through the number of entries there are for this author
while(entries) {
	cout << iter->second << endl; // print each title
	++iter; // advance to the next title
	--entries; // keep track of how many we've printed
}
//We start by determining how many entries there are for the author by calling count and getting an iterator to the first element with this key by calling find. The number of iterations of the for loop depends on the number returned from count. In particular, if the count was zero, then the loop is never executed.
//Note: We are guaranteed that iterating across a multimap or multiset returns all the elements with a given key in sequence.

//A Different, Iterator-Oriented Solution
//Alternatively, we can solve our problem using lower_bound and upper_bound. Each of these operations take a key and returns an iterator. If the key is in the container, the iterator returned from lower_bound will refer to the first instance of that key and the iterator returned by upper_bound will refer just after the last instance of the key. If the element is not in the multimap, then lower_bound and upper_bound will return equal iterators; both will refer to the point at which the key can be inserted without disrupting the order. Thus, calling lower_bound and upper_bound on the same key yields an iterator range that denotes all the elements with that key.
//Of course, the iterator returned from these operations might be the off-the-end iterator for the container itself. If the element we’re looking for has the largest key in the container, then upper_bound on that key returns the off-the-end iterator. If the key is not present and is larger than any key in the container, then the return from lower_bound will also be the off-the-end iterator.

//Note: The iterator returned from lower_bound may or may not refer to an element with the given key. If the key is not in the container, then lower_bound refers to the first point at which this key can be inserted while preserving the element order within the container.

//Using these operations, we can rewrite our program as follows:
// definitions of authors and search_item as above
// beg and end denote the range of elements for this author
for (auto beg = authors.lower_bound(search_item), end = authors.upper_bound(search_item); beg != end; ++beg)
	cout << beg->second << endl; // print each title
//This program does the same work as the previous one that used count and find but accomplishes its task more directly. The call to lower_bound positions beg so that it refers to the first element matching search_item if there is one. If there is no such element, then beg refers to the first element with a key larger than search_item, which could be the off-the-end iterator. The call to upper_bound sets end to refer to the element just beyond the last element with the given key. These operations say nothing about whether the key is present. The important point is that the return values act like an iterator range.
//If there is no element for this key, then lower_bound and upper_bound will be equal. Both will refer to the point at which this key can be inserted while maintaining the container order.
//Assuming there are elements with this key, beg will refer to the first such element. We can increment beg to traverse the elements with this key. The iterator in end will signal when we’ve seen all the elements. When beg equals end, we have seen every element with this key.
//Because these iterators form a range, we can use a for loop to traverse that range. The loop is executed zero or more times and prints the entries, if any, for the given author. If there are no elements, then beg and end are equal and the loop is never executed. Otherwise, we know that the increment to beg will eventually reach end and that in the process we will print each record associated with this author.

//Note: If lower_bound and Upper_bound return the same iterator, then the given key is not in the container.

//The equal_range Function
//The remaining way to solve this problem is the most direct of the three approaches: Instead of calling upper_bound and lower_bound, we can call equal_range. This function takes a key and returns a pair of iterators. If the key is present, then the first iterator refers to the first instance of the key and the second iterator refers one past the last instance of the key. If no matching element is found, then both the first and second iterators refer to the position where this key can be inserted.
//We can use equal_range to modify our program once again:
// definitions of authors and search_item as above pos holds iterators that denote the range of elements for this key
for (auto pos = authors.equal_range(search_item); pos.first != pos.second; ++pos.first)
	cout<<pos.first->second<<endl;    //print each title
//This program is essentially identical to the previous one that used upper_bound and lower_bound. Instead of using local variables, beg and end, to hold the iterator range, we use the pair returned by equal_range. The first member of that pair holds the same iterator as lower_bound would have returned and second holds the iterator upper_bound would have returned. Thus, in this program pos.first is equivalent to beg, and pos.second is equivalent to end.

//11.3.6 A Word Transformation Map

//We’ll close this section with a program to illustrate creating, searching, and iterating across a map. We’ll write a program that, given one string, transforms it into another. The input to our program is two files. The first file contains rules that we will use to transform the text in the second file. Each rule consists of a word that might be in the input file and a phrase to use in its place. The idea is that whenever the first word appears in the input, we will replace it with the corresponding phrase. The second file contains the text to transform.

//11.4 The Unordered Containers

//The new standard defines four unordered associative containers. Rather than using a comparison operation to organize their elements, these containers use a hash function and the key type's == operator. An unordered container is most useful when we have a key type for which there is no obvious ordering relationship among the elements. These containers are also useful for applications in which the cost of maintaining the elements in order is prohibitive.
//Although hashing gives better average case performance in principle, achieving good results in practice often requires a fair bit of performance testing and tweaking. As a result, it is usually easier (and often yields better performance) to use an ordered container.
//Tip: Use an unordered container if the key type is inherently unordered or if performance testing reveals problems that hashing might solve.

//Using an Unordered Container
//Aside from operations that manage the hashing, the unordered containers provide the same operations (find, insert, and so on) as the ordered containers. That means that the operations we’ve used on map and set apply to unordered_map and unordered_set as well. Similarly for the unordered versions of the containers that allow multiple keys.
//As a result, we can usually use an unordered container in place of the corresponding ordered container, and vice versa. However, because the elements are not stored in order, the output of a program that uses an unordered container will (ordinarily) differ from the same program using an ordered container.

//Managing the Buckets
//The unordered containers are organized as a collection of buckets, each of which holds zero or more elements. These containers use a hash function to map elements to buckets. To access an element, the container first computes the element’s hash code, which tells which bucket to search. The container puts all of its elements with a given hash value into the same bucket. If the container allows multiple elements with a given key, all the elements with the same key will be in the same bucket. As a result, the performance of an unordered container depends on the quality of its hash function and on the number and size of its buckets.
//The hash function must always yield the same result when called with the same argument. Ideally, the hash function also maps each particular value to a unique bucket. However, a hash function is allowed to map elements with differing keys to the same bucket. When a bucket holds several elements, those elements are searched sequentially to find the one we want. Typically, computing an element’s hash code and finding its bucket is a fast operation. However, if the bucket has many elements, many comparisons may be needed to find a particular element.
//The unordered containers provide a set of functions, listed in Table below, that let us manage the buckets. These members let us inquire about the state of the container and force the container to reorganize itself as needed.
//Unordered Container Management Operations
//Bucket Interface
c.bucket_count();    //Number of buckets in use;
c.max_bucket_count();    //Largest number of buckets this container can hold;
c.bucket_size(n);    //Number of elements in the nth bucket;
c.bucket(k);    //Bucket in which elements with key k would be found;
//Bucket Iteration
local_iterator;    //Iterator type that can access elements in a bucket;
const_local_iterator;    //const version of the bucket iterator;
c.begin(n), c.end(n);    //Iterator to the first, one past the last element in bucket n;
c.cbegin(n), c.cend(n);    //Returns const_local_iterator;
//Hash Policy
c.load_factor();    //Average number of elements per bucket. Returns float;
c.max_load_factor();    //Average bucket size that c tries to maintain. c adds buckets to keep load_fafctor <= max_load_factor. Returns float;
c.rehash(n);    //Reorganize storage so that bucket_count >= n and bucket_count > size/max_load_factor;
c.reserve(n);    //Reorganize so that c can hold n elements without a rehash;

//Requirements on Key Type for Unordered Container
//By default, the unordered containers use the == operator on the key type to compare elements. They also use an object of type hash<key_type> to generate the hash code for each element. The library supplies versions of the hash template for the builtin types, including pointers. It also defines hash for some of the library types, including strings and the smart pointer types that we will describe in Chapter 12. Thus, we can directly define unordered containers whose key is one of the built-in types (including pointer types), or a string, or a smart pointer.
//However, we cannot directly define an unordered container that uses a our own class types for its key type. Unlike the containers, we cannot use the hash template directly. Instead, we must supply our own version of the hash template. We’ll see how to do so in § 16.5 (p. 709).
//Instead of using the default hash, we can use a strategy similar to the one we used to override the default comparison operation on keys for the ordered containers. To use Sales_data as the key, we’ll need to supply functions to replace both the == operator and to calculate a hash code. We’ll start by defining these functions:
size_t hasher(const Sales_data &sd) {
	return hash<string>()(sd.isbn());
}
bool eqOp(const Sales_data &lhs, const Sales_data &rhs) {
	return lhs.isbn() == rhs.isbn();
}
//Our hasher function uses an object of the library hash of string type to generate a hash code from the ISBN member. Similarly, the eqOp funciton compares two Sales_data objects by comparing their ISBNs.
//We can use these functions to define an unordered_multiset as follows
using SD_multiset = unordered_multiset<Sales_data, decltype(hasher)*, decltype(eqOp)*>;
// arguments are the bucket size and pointers to the hash function and equality operator
SD_multiset bookstore(42, hasher, eqOp);
//To simplify the declaration of bookstore we first define a type alias for an unordered_multiset whose hash and equality operations have the same  types as our hasher and eqOp functions. Using that type, we define bookstore passing pointers to the functions we want bookstore to use.
//If our class has its own == operator we can override just the hash function:
// use FooHash to generate the hash code; Foo must have an == operator
unordered_set<Foo, decltype(FooHash)*> fooSet(10, FooHash);
