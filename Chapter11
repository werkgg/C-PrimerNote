//Chapter11 Associative Containers

//Associative and sequential containers differ from one another in a fundamental way: Elements in an associative container are stored and retrieved by a key. In contrast, elements in a sequential container are stored and accessed sequentially by their position in the container.
//Although the associative containers share much of the behavior of the sequential containers, they differ from the sequential containers in ways that reflect the use of keys.
//Associative containers support efficient lookup and retrieval by a key. The two primary associative-container types are map and set. The elements in a map are key–value pairs: The key serves as an index into the map, and the value represents the data associated with that index. A set element contains only a key; a set supports efficient queries as to whether a given key is present. We might use a set to hold words that we want to ignore during some kind of text processing. A dictionary would be a good use for a map: The word would be the key, and its definition would be the value.
//The library provides eight associative containers, listed in Table below. These eight differ along three dimensions: Each container is (1) a set or a map, (2) requires unique keys or allows multiple keys, and (3) stores the elements in order or not. The containers that allow multiple keys include the word multi; those that do not keep their keys ordered start with the word unordered. Hence an unordered_multi_set is a set that allows multiple keys whose elements are not stored in order, whereas a set has unique keys that are stored in order. The unordered containers use a hash function to organize their elements. We’ll have more to say about the hash function in § 11.4 (p. 444).
//Associative Container Types
//Elements Ordered by Key
map;    //Associative array; holds key-value pairs;
set;    //Container in which the key is the value; set is usually implemented by red-black tree;
multimap;    //map in which a key can appear multiple times;
multiset;    //set in which a key can appear multiple times;
//Unordered Collections
unordered_map;    //map organized by a hash function;
unordered_set;    //set organized by a hash function;
unordered_multimap;    //Hashed map; keys can appear multiple times;
unordered_multiset;    //Hashed set; keys can appear multiple times;
//The map and multimap types are defined in the map header; the set and multiset types are in the set header; and the unordered containers are in the unordered_map and unordered_set headers.

//11.1 Using an Associative Container

//Although most programmers are familiar with data structures such as vectors and lists, many have never used an associative data structure. Before we look at the details of how the library supports these types, it will be helpful to start with examples of how we can use these containers.
//A map is a collection of key–value pairs. For example, each pair might contain a person’s name as a key and a phone number as its value. We speak of such a data structure as “mapping names to phone numbers.” The map type is often referred to as an associative array. An associative array is like a “normal” array except that its subscripts don’t have to be integers. Values in a map are found by a key rather than by their position. Given a map of names to phone numbers, we’d use a person’s name as a subscript to fetch that person’s phone number.
//In contrast, a set is simply a collection of keys. A set is most useful when we simply want to know whether a value is present. For example, a business might define a set named bad_checks to hold the names of individuals who have written bad checks. Before accepting a check, that business would query bad_checks to see whether the customer’s name was present.

//Using a map
//A classic example that relies on associative arrays is a word-counting program:
// count the number of times each word occurs in the input
map<string, size_t> word_count; // empty map from string to size_t
string word;
while (cin >> word)
	++word_count[word]; // fetch and increment the counter for word
for (const auto &w : word_count) // for each element in the map
	// print the results
	cout << w.first << " occurs " << w.second << ((w.second > 1) ? " times" : " time") << endl;
//This program reads its input and reports how often each word appears.
//Like the sequential containers, the associative containers are templates To define a map, we must specify both the key and value types. In this program, the map stores elements in which the keys are strings and the values are size_ts. When we subscript word_count, we use a string as the subscript, and we get back the size_t counter associated with that string.
//The while loop reads the standard input one word at a time. It uses each word to subscript word_count. If word is not already in the map, the subscript operator creates a new element whose key is word and whose value is 0. Regardless of whether the element had to be created, we increment the value.
//Once we’ve read all the input, the range for (§ 3.2.3, p. 91) iterates through the map, printing each word and the corresponding counter. When we fetch an element from a map, we get an object of type pair, which we’ll describe in § 11.2.3 (p. 426).Briefly, a pair is a template type that holds two (public) data elements named first and second. The pairs used by map have a first member that is the key and a second member that is the corresponding value. Thus, the effect of the output statement is to print each word and its associated counter.

//Using a set
//A logical extension to our program is to ignore common words like “the,” “and,” “or,” and so on. We’ll use a set to hold the words we want to ignore and count only those words that are not in this set:
// count the number of times each word occurs in the input
map<string, size_t> word_count; // empty map from string to size_t
set<string> exclude = {"The", "But", "And", "Or", "An", "A", "the", "but", "and", "or", "an", "a"};
string word;
while (cin >> word)
	// count only words that are not in exclude
	if (exclude.find(word) == exclude.end())
		++word_count[word]; // fetch and increment the counter for word
//Like the other containers, set is a template. To define a set, we specify the type of its elements, which in this case are strings. As with the sequential containers, we can list initialize the elements of an associative container. Our exclude set holds the 12 words we want to ignore.
//The important difference between this program and the previous program is that before counting each word, we check whether the word is in the exclusion set. We do this check in the if:
// count only words that are not in exclude
if (exclude.find(word) == exclude.end())
//The call to find returns an iterator. If the given key is in the set, the iterator refers to that key. If the element is not found, find returns the off-the-end iterator. In this version, we update the counter for word only if word is not in exclude.

//11.2 Overview of the Associative Containers
//Associative containers (both ordered and unordered) support the general container operations covered in § 9.2 (p. 328) and listed in Table 9.2 (p. 330). The associative containers do not support the sequential-container position-specific operations, such as push_front or back. Because the elements are stored based on their keys, these operations would be meaningless for the associative containers. Moreover, the associative containers do not support the constructors or insert operations that take an element value and a count.
//In addition to the operations they share with the sequential containers, the associative containers provide some operations (Table 11.7 (p. 438)) and type aliases (Table 11.3 (p. 429)) that the sequential containers do not. In addition, the unordered containers provide operations for tuning their hash performance, which we’ll cover in § 11.4 (p. 444).
//The associative container iterators are bidirectional.

//11.2.1 Defining an Associative Container
//As we’ve just seen, when we define a map, we must indicate both the key and value type; when we define a set, we specify only a key type, because there is no value type. Each of the associative containers defines a default constructor, which creates an empty container of the specified type. We can also initialize an associative container as a copy of another container of the same type or from a range of values, so long as those values can be converted to the type of the container. Under the new standard, we can also list initialize the elements:
map<string, size_t> word_count; // empty
// list initialization
set<string> exclude = {"the", "but", "and", "or", "an", "a", "The", "But", "And", "Or", "An", "A"};
// three elements; authors maps last name to first
map<string, string> authors = { {"Joyce", "James"},
								{"Austen", "Jane"},
								{"Dickens", "Charles"} };
//As usual, the initializers must be convertible to the type in the container. For set, the element type is the key type.
//When we initialize a map, we have to supply both the key and the value. We wrap each key–value pair inside curly braces:
{key, value}
//to indicate that the items together form one element in the map. The key is the first element in each pair, and the value is the second. Thus, authors maps last names to first names, and is initialized with three elements.

//Initializing a multimap or multiset
//The keys in a map or a set must be unique; there can be only one element with a given key. The multimap and multiset containers have no such restriction; there can be several elements with the same key. For example, the map we used to count words must have only one element per given word. On the other hand, a dictionary could have several definitions associated with a particular word.

//11.2.2 Requirements on Key Type

//The associative containers place constraints on the type that is used as a key. We’ll cover the requirements for keys in the unordered containers in § 11.4 (p. 445). For the ordered containers—map, multimap, set, and multiset—the key type must define a way to compare the elements. By default, the library uses the < operator for the key type to compare the keys. In the set types, the key is the element type; in the map types, the key is the first type.

//Note: Callable objects passed to a sort algorithm must meet the same requirements as do the keys in an associative container.

//Key Types for Ordered Containers

//Just as we can provide our own comparison operation to an algorithm, we can also supply our own operation to use in place of the < operator on keys. The specified operation must define a strict weak ordering over the key type. We can think of a strict weak ordering as “less than,” although our function might use a more complicated procedure. However we define it, the comparison function must have the following properties:
//• Two keys cannot both be “less than” each other; if k1 is “less than” k2, then k2 must never be “less than” k1.
//• If k1 is “less than” k2 and k2 is “less than” k3, then k1 must be “less than” k3.
//• If there are two keys, and neither key is “less than” the other, then we’ll say that those keys are “equivalent.” If k1 is “equivalent” to k2 and k2 is “equivalent” to k3, then k1 must be “equivalent” to k3.
//If two keys are equivalent (i.e., if neither is “less than” the other), the container treats them as equal. When used as a key to a map, there will be only one element associated with those keys, and either key can be used to access the corresponding value.
//Note: In practice, what’s important is that a type that defines a < operator that “behaves normally” can be used as a key.

//Using a Comparison Function for the Key Type
//The type of the operation that a container uses to organize its elements is part of the type of that container. To specify our own operation, we must supply the type of that operation when we define the type of an associative container. The operation type is specified following the element type inside the angle brackets that we use to say which type of container we are defining.
//Each type inside the angle brackets is just that, a type. We supply a particular comparison operation (that must have the same type as we specified inside the angle brackets) as a constructor argument when we create a container.
//For example, we can’t directly define a multiset of Sales_data because Sales_data doesn’t have a < operator. However, we can use the compareIsbn function from the exercises in § 10.3.1 (p. 387) to define a multiset. That function defines a strict weak ordering based on their ISBNs of two given Sales_data objects. The compareIsbn function should look something like
bool compareIsbn(const Sales_data &lhs, const Sales_data &rhs) {
	return lhs.isbn() < rhs.isbn();
}
//To use our own operation, we must define the multiset with two types: the key type, Sales_data, and the comparison type, which is a function pointer type that can point to compareIsbn. When we define objects of this type, we supply a pointer to the operation we intend to use. In this case, we supply a pointer to compareIsbn:
// bookstore can have several transactions with the same ISBN, elements in bookstore will be in ISBN order
multiset<Sales_data, decltype(compareIsbn)*> bookstore(compareIsbn);
//Here, we use decltype to specify the type of our operation, remembering that when we use decltype to form a function pointer, we must add a * to indicate that we’re using a pointer to the given function type. We initialize bookstore from compareIsbn, which means that when we add elements to bookstore, those elements will be ordered by calling compareIsbn. That is, the elements in bookstore will be ordered by their ISBN members. We can write compareIsbn instead of &compareIsbn as the constructor argument because when we use the name of a function, it is automatically converted into a pointer if needed. We could have written &compareIsbn with the same effect.

//11.2.3 The pair Type

//pair is defined in the utility header. A pair holds two data members. Like the containers, pair is a template from which we generate specific types. We must supply two type names when we create a pair. The data members of the pair have the corresponding types. There is no requirement that the two types be the same.

//The default pair constructor value initializes the data members.

//Unlike other library types, the data members of pair are public. These members are named first and second, respectively. We access these members using the normal member access notation (§ 1.5.2, p. 23), as, for example, we did in the output statement of our word-counting program on page 421:
// print the results
cout << w.first << " occurs " << w.second << ((w.second > 1) ? " times" : " time") << endl;
//Here, w is a reference to an element in a map. Elements in a map are pairs. In this statement we print the first member of the element, which is the key, followed by the second member, which is the counter.

//Opeartions on pairs
pair<T1, T2> p;    //p is a pair with value initialized members of types T1 and T2, respectively;
pair<T1, T2> p(v1, v2);    //p is a pair with types T1 and T2; the first and second members are initialized from v1 and v2, respectively;
pair<T1, T2> p = {v1, v2};    //Equivalent to p(v1, v2);
make_pair(v1, v2);    //Returns a pair initialized from v1 and v2. The type of the pair is inferred from the types of v1 and v2;
p.first;    //Returns the (public) data member of p named first;
p.second;    //Returns the (public) data member of p named second;
p1 reloy p2;    //Relational operators (<, >, <=, >=). Relational operators are defined as dictionary ordering; For example, p1<p2 is true if p1.first<p2.first or if !(p2.first<p1.first)&&p1.second<p2.second. Uses the element's < operator;
p1 == p2;    //Two pairs are equal if their first and second members are respectively equal. Uses the element's == operator;
p1 != p2;

//A Function to Create pair Objects
//Imagine we have a function that needs to return a pair. Under the new standard we can list initialize the return value:
pair<string, int> process(vector<string> &v) {
	// process v
	if (!v.empty())
		return {v.back(), v.back().size()}; // list initialize
	else
		return pair<string, int>(); // explicitly constructed return value
}
//If v isn’t empty, we return a pair composed of the last string in v and the size of that string. Otherwise, we explicitly construct and return an empty pair.
//Under earlier versions of C++, we couldn’t use braced initializers to return a type like pair. Instead, we might have written both returns to explicitly construct the return value:
if (!v.empty())
	return pair<string, int>(v.back(), v.back().size());
//Alternatively, we could have used make_pair to generate a new pair of the appropriate type from its two arguments:
if (!v.empty())
	return make_pair(v.back(), v.back().size());

//11.3 Operations on Associative Containers

//Associative containers define the types listed in Table below. These types represent the container's key and value types.
//Associative Container Additional Types Aliases
key_type;    //Type of key for this container type;
mapped_type;    //Type associated with each key; map types only;
value_type;    //For sets, same as the key_type; For maps, pair<const key_type, mapped_type>;
//For the set types, the key_type and the value_type are the same; the values held in a set are the keys. In a map, the elements are key–value pairs. That is, each element is a pair object containing a key and a associated value. Because we cannot change an element’s key, the key part of these pairs is const:
set<string>::value_type v1; // v1 is a string
set<string>::key_type v2; // v2 is a string
map<string, int>::value_type v3; // v3 is a pair<const string, int>
map<string, int>::key_type v4; // v4 is a string
map<string, int>::mapped_type v5; // v5 is an int
//As with the sequential containers, we use the scope operator to fetch a type member—for example, map<string, int>::key_type.
//Only the map types (unordered_map, unordered_multimap, multimap, and map) define mapped_type.

//11.3.1 Associative Container Iterators
//When we dereference an iterator, we get a reference to a value of the container's value_type. In the case of map, the value_type is a pair in which first holds the const key and second holds the value:
// get an iterator to an element in word_count
auto map_it = word_count.begin();
// *map_it is a reference to a pair<const string, size_t> object
cout << map_it->first; // prints the key for this element
cout << " " << map_it->second; // prints the value of the element
map_it->first = "new key"; // error: key is const
++map_it->second; // ok: we can change the value through an iterator
//Note: It is essential to remember that the value_type of a map is a pair and that we can change the value but not the key member of that pair.

//Iterators for set are Const
//Although the set types define both the iterator and const_iterator types, both types of iterators give us read-only access to the elements in the set. Just as we cannot change the key part of a map element, the keys in a set are also const. We can use a set iterator to read, but not write, an element’s value:
set<int> iset = {0,1,2,3,4,5,6,7,8,9};
set<int>::iterator set_it = iset.begin();
if (set_it != iset.end()) {
	*set_it = 42; // error: keys in a set are read-only
	cout << *set_it << endl; // ok: can read the key
}

//Iterating across an Associative Container
//The map and set types provide all the begin and end operations from Table 9.2 (p. 330). As usual, we can use these functions to obtain iterators that we can use to traverse the container. For example, we can rewrite the loop that printed the results in our word-counting program on page 421 as follows:
// get an iterator positioned on the first element
auto map_it = word_count.cbegin();
// compare the current iterator to the off-the-end iterator
while (map_it != word_count.cend()) {
	// dereference the iterator to print the element key--value pairs
	cout << map_it->first << " occurs " << map_it->second << " times" << endl;
	++map_it; // increment the iterator to denote the next element
}
//Note: The output of this program is in alphabetical order. When we use an iterator to traverse a map, multimap, set, or multiset, the iterators yield elements in ascending key order.

//Associative Containers and Algorithms
//In general, we do not use the generic algorithms with the associative containers. The fact that the keys are const means that we cannot pass associative container iterators to algorithms that write to or reorder container elements. Such algorithms need to write to the elements. The elements in the set types are const, and those in maps are pairs whose first element is const.
//Associative containers can be used with the algorithms that read elements. However, many of these algorithms search the sequence. Because elements in an associative container can be found (quickly) by their key, it is almost always a bad idea to use a generic search algorithm. For example, as we’ll see in § 11.3.5 (p. 436), the associative containers define a member named find, which directly fetches the element with a given key. We could use the generic find algorithm to look for an element, but that algorithm does a sequential search. It is much faster to use the find member defined by the container than to call the generic version.
//In practice, if we do so at all, we use an associative container with the algorithms either as the source sequence or as a destination. For example, we might use the generic copy algorithm to copy the elements from an associative container into another sequence. Similarly, we can call inserter to bind an insert iterator to an associative container. Using inserter, we can use the associative container as a destination for another algorithm.

//11.3.2 Adding Elements
//The insert members add one element or a range of elements. Because map and set (and the corresponding unordered types) contain unique key, inserting an element that is already present has no effect:
vector<int> ivec = {2,4,6,8,2,4,6,8}; // ivec has eight elements
set<int> set2; // empty set
set2.insert(ivec.cbegin(), ivec.cend()); // set2 has four elements
set2.insert({1,3,5,7,1,3,5,7}); // set2 now has eight elements
//Associative Container insert Operations
c.insert(v);    //v value_type object; args are used to construct an element;
c.emplace(args);    //For map and set, the element is inserted (or constructed) only if an element with the given key is not already in c. Returns a pair containing an iterator referring to the element with the given key and a bool indicating whether the element was inserted. For multimap and multiset, insert (or constructs) the given element and returns an iterator to the new element;
c.insert(b, e);    //b and e are iterators that denote a range of c::value_type values;
c.insert(il);    //il is a braced list of such values. Returns void. For map and set, inserts the elements with key that are not already in c. For multimap and multiset inserts, each element in the range;
c.insert(p, v);    //Like insert(v) (or emplace(args)), but uses iterator p as a hint for where to begin the search for where the new element should be stored. Returns an iterator to the element with the given key;
c.emplace(p, args);
//The versions of insert that take a pair of iterators or an initializer list work similarly to the corresponding constructors—only the first element with a given key is inserted.

//Adding Elements to a map
//When we insert into a map, we must remember that the element type is a pair. Often, we don’t have a pair object that we want to insert. Instead, we create a pair in the argument list to insert:
// four ways to add word to word_count
word_count.insert({word, 1});
word_count.insert(make_pair(word, 1));
word_count.insert(pair<string, size_t>(word, 1));
word_count.insert(map<string, size_t>::value_type(word, 1));
//As we’ve seen, under the new standard the easiest way to create a pair is to use brace initialization inside the argument list. Alternatively, we can call make_pair or explicitly construct the pair. The argument in the last call to insert:
map<string, size_t>::value_type(s, 1)
//constructs a new object of the appropriate pair type to insert into the map.

//Testing the Return from insert
//The value returned by insert (or emplace) depends on the container type and the parameters. For the containers that have unique keys, the versions of insert and emplace that add a single element return a pair that lets us know whether the insertion happened. The first member of the pair is an iterator to the element with the given key; the second is a bool indicating whether that element was inserted, or was already there. If the key is already in the container, then insert does nothing, and the bool portion of the return value is false. If the key isn’t present, then the element is inserted and the bool is true.
//As an example, we’ll rewrite our word-counting program to use insert:
// more verbose way to count number of times each word occurs in the input
map<string, size_t> word_count; // empty map from string to size_t
string word;
while (cin >> word) {
	// inserts an element with key equal to word and value 1;
	// if word is already in word_count, insert does nothing
	auto ret = word_count.insert({word, 1});
	if (!ret.second) // word was already in word_count
		++ret.first->second; // increment the counter
}

//Unwinding the Syntax
//The statement that increments the counter in this version of word-counting program can be hard to understand. It will be easier to understand that expression by first parenthesizing it to reflect the precedence of the operator:
++((ret.first)->second); // equivalent expression
//Explaining this expression step by step:
//ret holds the value returned by insert, which is a pair.
//ret.first is the first member of that pair, which is a map iterator referring to the element with the given key.
//ret.first-> dereferences that iterator to fetch that element. Elements in the map are also pairs.
//ret.first->second is the value part of the map element pair.
//++ret.first->second increments that value.
//Putting it back together, the increment statement fetches the iterator for the element with the key word and increments the counter associated with the key we tried to insert.
//For readers using an older compiler or reading code that predates the new standard, declaring and initializing ret is also somewhat tricky:
pair<map<string, size_t>::iterator, bool> ret = word_count.insert(make_pair(word, 1));
//It should be easy to see that we’re defining a pair and that the second type of the pair is bool. The first type of that pair is a bit harder to understand. It is the iterator type defined by the map<string, size_t> type.

//Adding Elements to multiset or multimap
//Our word-counting program depends on the fact that a given key can occur only once. That way, there is only one counter associated with any given word. Sometimes, we want to be able to add additional elements with the same key. For example, we might want to map authors to titles of the books they have written. In this case, there might be multiple entries for each author, so we’d use a multimap rather than a map. Because keys in a multi container need not be unique, insert on these types always inserts an element:
multimap<string, string> authors;
// adds the first element with the key Barth, John
authors.insert({"Barth, John", "Sot-Weed Factor"});
// ok: adds the second element with the key Barth, John
authors.insert({"Barth, John", "Lost in the Funhouse"});
//For the containers that allow multiple keys, the insert operation that takes a single element returns an iterator to the new element. There is no need to return a bool, because insert always adds a new element in these types.

//11.3.3 Erasing Elements
//The associative containers define three versions of erase, which are described in Table below. As with the sequential containers, we can erase one element or a range of elements by passing erase an iterator or an iterator pair. These versions of erase are similar to the corresponding operations on sequential containers: The indicated element(s) are removed and the function returns void.
//Removing Elements from an Associative Container
c.erase(k);    //Removes every element with key k from c. Returns size_type indicating the number of elements removed;
c.erase(p);    //Removes the element denoted by the iterator p from c. p must refer to an actual element in c; it must not be equal to c.end(). Returns an iterator to the element after p or c.end() if p denotes the last element in c;
c.erase(b, e);    //Removes the elements in the range denoted by the iterator pair b, e. Returns e;
//The associative containers supply an additional erase operation that takes a key_type argument. This version removes all the elements, if any, with the given key and returns a count of how many elements were removed. We can use this version to remove a specific word from word_count before printing the results:
// erase on a key returns the number of elements removed
if (word_count.erase(removal_word))
	cout << "ok: " << removal_word << " removed\n";
else cout << "oops: " << removal_word << " not found!\n";
//For the containers with unique keys, the return from erase is always either zero or one. If the return value is zero, then the element we wanted to erase was not in the container.
//For types that allow multiple keys, the number of elements removed could be greater than one:
auto cnt = authors.erase("Barth, John");
//If authors is the multimap we created in § 11.3.2 (p. 434), then cnt will be 2.















