//Chapter 07 Classes

//The fundamental ideas behind classes are data abstraction and encapsulation. Data abstraction is a programming (and design) technique that relies on the separation of interface and implementation. The interface of a class consists of the operations that users of the class can execute. The implementation includes the class’ data members, the bodies of the functions that constitute the interface, and any functions needed to define the class that are not intended for general use.
//Encapsulation enforces the separation of a class’ interface and implementation. A class that is encapsulated hides its implementation—users of the class can use the interface but have no access to the implementation.
//A class that uses data abstraction and encapsulation defines an abstract data type. In an abstract data type, the class designer worries about how the class is implemented. Programmers who use the class need not know how the type works. They can instead think abstractly about what the type does.

//7.1 Defining Abstract Data Types

//7.1.1 Designing the Sales_data Class

//The functions that do addition and IO will not be members of Sales_data. Instead, we will define those functions as ordinary functions.
//The function that handles compound assignment will be a member.

//7.2 Defining the Revised Sales_data Class

//Member functions must be declared inside the class. Member functions may be defined inside the class itself or outside the class body. Nonmember functions that are part of the interface, are declared and defined outside the class.

//Functions defined in the class are implicitly inline.

//Although every member must be declared inside its class, we can define a member function's body either inside or outside of the class body.

//Member functions access the object on which they were called through an extra, implicit parameter named this. When we call a member function, this is initialized with the address of the object on which the function was invoked.

//Inside a member function, we can refer directly to the members of the object on which the function was called. We do not have to use a member access operator to use the members of the object to which this points. Any direct use of a member of the class is assumed to be an implicit reference through this.

//The this parameter is defined for us implicitly. Indeed, it is illegal for us to define a parameter or variable named this.

//Because this is intended to always refer to "this" object, this is a const pointer. We cannot change the address that this holds.

//Introducing const Member Functions

std::string isbn() const{return bookNo;}
//The other important part about the isbn function is the keyword const that follows the parameter list. The purpose of that const is to modify the type of the implicit this pointer.

//By default, the type of this is a const pointer to the nonconst version of the class type. For example, by default, the type of this in a Sales_data member function is Sales_data *const. Although this is implicit, it follows the normal initialization rules, which means that (by default) we cannot bind this to a const object. This fact, in turn, means that we cannot call an ordinary member function on a const object.

//However, this is implicit and does not appear in the parameter list. There is no place to indicate that this should be a pointer to const. The language resolves this problem by letting us put const after the parameter list of a member function. A const following the parameter list indicates that this is a pointer to const. Member functions that use const in this way are const member functions.

//The fact that this is a pointer to const means that const member functions cannot change the object on which they are called.

//Class Scope and Member Functions
//The compiler processes classes in two steps— the member declarations are compiled first, after which the member function bodies, if any, are processed. Thus, member function bodies may use other members of their class regardless of where in the class those members appear.

//Defining a Member Function outside the Class
//As with any other function, when we define a member function outside the class body, the member’s definition must match its declaration. That is, the return type, parameter list, and name must match the declaration in the class body. If the member was declared as a const member function, then the definition must also specify const after the parameter list. The name of a member defined outside the class must include the name of the class of which it is a member.
//scope operator ::

//Once the compiler sees the function name, the rest of the code is interpreted as being inside the scope of the class.

//Defining a Function to Return "This" Object
//Ordinarily, when we define a function that operates like a built-in operator, our function should mimic the behavior of that operator. The built-in assignment operators return their left-hand operand as an lvalue. To return an lvalue, our combine function must return a reference. Because the left-hand operand is a Sales_data object, the return type is Sales_data&.

//As we've seen, we do not need to use the implicit this pointer to access the members of the object on which a member function is executing. However, we do need to use this to access the object as a whole:
//return *this;    //return the object on which the function was called
//Here the return statement dereference this to obtain the object on which the function is executing. That is, for the call above, we return a reference to total.

//7.1.3 Defining Nonmember Class-Related Functions

//We define nonmember functions as we would any other function. As with any other function, we normally separate the declaration of the function from its definition. Functions that are conceptually part of a class, but not defined inside the class, are typically declared (but not defined) in the same header as the class itself. That way users need to include only one file to use any part of the interface.
//Ordinarily, nonmember functions that are part of the interface of a class should be declared in the same header as the class itself.

//there are two points worth noting about these functions. First, both read and write take a reference to their respective IO class types. The IO classes are types that cannot be copied, so we may only pass them by reference. Moreover, reading or writing to a stream changes that stream, so both functions take ordinary references, not references to const.
//The second thing to note is that print does not print a newline. Ordinarily, functions that do output should do minimal formatting. That way user code can decide whether the newline is needed.

//7.1.4 Constructors

//Each class defines how objects of its type can be initialized. Classes control object initialization by defining one or more special member functions known as constructors. The job of a constructor is to initialize the data members of a class object. A constructor is run whenever an object of a class type is created.

//Constructors have the same name as the class. Unlike other functions, constructors have no return type. Like other functions, constructors have a (possibly empty) parameter list and a (possibly empty) function body. A class can have multiple constructors. Like any other overloaded function, the constructors must differ from each other in the number or types of their parameters.
//Unlike other member functions, constructors may not be declared as const. When we create a const object of a class type, the object does not assume its “constness” until after the constructor completes the object’s initialization. Thus, constructors can write to const objects during their construction.

//The Synthesized Default Constructor

//We did not supply an initializer for these objects, so we know that they are default initialized. Classes control default initialization by defining a special constructor, known as the default constructor. The default constructor is one that takes no arguments.

//As we’ll, see the default constructor is special in various ways, one of which is that if our class does not explicitly define any constructors, the compiler will implicitly define the default constructor for us.
//The compiler-generated constructor is known as the synthesized default constructor. For most classes, this synthesized constructor initializes each data member of the class as follows:
//If there is an in-class initializer (§ 2.6.1, p. 73), use it to initialize the member.
//Otherwise, default-initialize (§ 2.2.1, p. 43) the member.
//Because Sales_data provides initializers for units_sold and revenue, the synthesized default constructor uses those values to initialize those members. It default initializes bookNo to the empty string.

//Some Class Cannot Rely on the Synthesized Default Constructor
//Only fairly simple classes—such as the current definition of Sales_data—can rely on the synthesized default constructor. The most common reason that a class must define its own default constructor is that the compiler generates the default for us only if we do not define any other constructors for the class. If we define any constructors, the class will not have a default constructor unless we define that constructor ourselves. The basis for this rule is that if a class requires control to initialize an object in one case, then the class is likely to require control in all cases.
//A second reason to define the default constructor is that for some classes, the synthesized default constructor does the wrong thing. Remember that objects of builtin or compound type (such as arrays and pointers) that are defined inside a block have undefined value when they are default initialized. The same rule applies to members of built-in type that are default initialized. Therefore, classes that have members of built-in or compound type should ordinarily either initialize those members inside the class or define their own version of the default constructor. Otherwise, users could create objects with members that have undefined value.
//A third reason that some classes must define their own default constructor is that sometimes the compiler is unable to synthesize one. For example, if a class has a member that has a class type, and that class doesn’t have a default constructor, then the compiler can’t initialize that member. For such classes, we must define our own version of the default constructor. Otherwise, the class will not have a usable default constructor. We’ll see in § 13.1.6 (p. 508) additional circumstances that prevent the compiler from generating an appropriate default constructor.
//The compiler generates a default constructor automatically only if a class declares no constructors.
//Classes that have members of built-in or compound type usually should rely on the synthesized default constructor only if all such members have in-class initializers.

//Defining the Sales_data Constructors:
//For our Sales_data class we’ll define four constructors with the following parameters:
//An istream& from which to read a transaction.
//A const string& representing an ISBN, an unsigned representing the count of how many books were sold, and a double representing the price at which the books sold.
//A const string& representing an ISBN. This constructor will use default values for the other members.
//An empty parameter list (i.e., the default constructor) which as we’ve just seen we must define because we have defined other constructors.
//Adding these members to our class, we now have
struct Sales_data {
    // constructors added
    Sales_data() = default;
	Sales_data(const std::string &s): bookNo(s) { }
	Sales_data(const std::string &s, unsigned n, double p):bookNo(s), units_sold(n), revenue(p*n) { }
	Sales_data(std::istream &);
	// other members as before
	std::string isbn() const { return bookNo; }
	Sales_data& combine(const Sales_data&);
	double avg_price() const;
	std::string bookNo;
	unsigned units_sold = 0;
	double revenue = 0.0;
};

//What is "default" Means
//The default constructor:
Sales_data()=default;
//First, note that this constructor defines the default constructor because it takes no arguments. We are defining this constructor only because we want to provide other constructors as well as the default constructor. We want this constructor to do exactly the same work as the synthesized version we had been using.
//Under the new standard, if we want the default behavior, we can ask the compiler to generate the constructor for us by writing = default after the parameter list. The = default can appear with the declaration inside the class body or on the definition outside the class body. Like any other function, if the = default appears inside the class body, the default constructor will be inlined; if it appears on the definition outside the class, the member will not be inlined by default.

//The default constructor works for Sales_data only because we provide initializers for the data members with built-in type. If your compiler does not support in-class initializers, your default constructor should use the constructor initializer list (described immediately following) to initialize every member of the class.

//Constructor Initializer List
Sales_data(const std::string &s): bookNo(s) { }
Sales_data(const std::string &s, unsigned n, double p):bookNo(s), units_sold(n), revenue(p*n) { }
//The new parts in these definitions are the colon and the code between it and the curly braces that define the (empty) function bodies. This new part is a constructor initializer list, which specifies initial values for one or more data members of the object being created. The constructor initializer is a list of member names, each of which is followed by that member’s initial value in parentheses (or inside curly braces). Multiple member initializations are separated by commas.

//The constructor that has three parameters uses its first two parameters to initialize the bookNo and units_sold members. The initializer for revenue is calculated by multiplying the number of books sold by the price per book. 
//The constructor that has a single string parameter uses that string to initialize bookNo but does not explicitly initialize the units_sold and revenue members. When a member is omitted from the constructor initializer list, it is implicitly initialized using the same process as is used by the synthesized default constructor. In this case, those members are initialized by the in-class initializers.

//It is usually best for a constructor to use an in-class initializer if one exists and gives the member the correct value. On the other hand, if your compiler does not yet support in-class initializers, then every constructor should explicitly initialize every member of built-in type.

//Best Practices: Constructors should not override in-class initializers except to use a different initial value. If you can’t use in-class initializers, each constructor should explicitly initialize every member of built-in type.

//It is worth noting that both constructors have empty function bodies. The only work these constructors need to do is give the data members their values. If there is no further work, then the function body is empty.

//Defining a Constructor outside the Class Body

//Unlike our other constructors, the constructor that takes an istream does have work to do. Inside its function body, this constructor calls read to give the data members new values:
Sales_data::Sales_data(std::istream &is){
    read(is, *this); // read will read a transaction from is into this object
}
//Constructors have no return type, so this definition starts with the name of the function we are defining. As with any other member function, when we define a constructor outside of the class body, we must specify the class of which the constructor is a member. Thus, Sales_data::Sales_data says that we’re defining the Sales_data member named Sales_data. This member is a constructor because it has the same name as its class.

//In this constructor there is no constructor initializer list, although technically speaking, it would be more correct to say that the constructor initializer list is empty. Even though the constructor initializer list is empty, the members of this object are still initialized before the constructor body is executed.
//Members that do not appear in the constructor initializer list are initialized by the corresponding in-class initializer (if there is one) or are default initialized.

//7.1.5 Copy, Assignment and Destruction
//In addition to defining how objects of the class type are initialized, classes also control what happens when we copy, assign, or destroy objects of the class type. Objects are copied in several contexts, such as when we initialize a variable or when we pass or return an object by value (§ 6.2.1, p. 209, and § 6.3.2, p. 224). Objects are assigned when we use the assignment operator (§ 4.4, p. 144). Objects are destroyed when they cease to exist, such as when a local object is destroyed on exit from the block in which it was created (§ 6.1.1, p. 204). Objects stored in a vector (or an array) are destroyed when that vector (or array) is destroyed.
//If we do not define these operations, the compiler will synthesize them for us. Ordinarily, the versions that the compiler generates for us execute by copying, assigning, or destroying each member of the object.

//Some Classes Cannot Rely on the Synthesized Versions

//7.2 Access Control and Encapsulation

//At this point, we have defined an interface for our class; but nothing forces users to use that interface. Our class is not yet encapsulated. In C++ we use access specifiers to enforce encapsulation:
//Members defined after a public specifier are accessible to all parts of the program. The public members define the interface to the class.
//Members defined after a private specifier are accessible to the member functions of the class but are not accessible to code that uses the class. The private sections encapsulate (i.e., hide) the implementation.

//A class may contain zero or more access specifiers, and there are no restrictions on how often an access specifier may appear. Each access specifier specifies the access level of the succeeding members. The specified access level remains in effect until the next access specifier or the end of the class body.

//Using the class or struct Keyword
//We also made another, more subtle, change: We used the class keyword rather than struct to open the class definition. This change is strictly stylistic; we can define a class type using either keyword. The only difference between struct and class is the default access level.
//A class may define members before the first access specifier. Access to such members depends on how the class is defined. If we use the struct keyword, the members defined before the first access specifier are public; if we use class, then the members are private.
//As a matter of programming style, when we define a class intending for all of its members to be public, we use struct. If we intend to have private members, then we use class.

//The only difference between using class and using struct to define a class is the default access level.

//7.2.1 Friends

//A class can allow another class or function to access its nonpublic members by making that class or function a friend. A class makes a function its friend by including a declaration for that function preceded by the keyword friend.
//Friend declarations may appear only inside a class definition; they may appear anywhere in the class. Friends are not members of the class and are not affected by the access control of the section in which they are declared.
//Friend declarations appear inside a class, and friend function declarations still appear outside of class.

//Ordinarily it is a good idea to group friend declarations together at the beginning or end of the class definition.

//Benefits of Encapsulation
Encapsulation provides two important advantages:
//User code cannot inadvertently corrupt the state of an encapsulated object.
//The implementation of an encapsulated class can change over time without requiring changes in user-level code.
//By defining data members as private, the class author is free to make changes in the data. If the implementation changes, only the class code needs to be examined to see what effect the change may have. User code needs to change only when the interface changes. If the data are public, then any code that used the old data members might be broken. It would be necessary to locate and rewrite any code that relied on the old representation before the program could be used again.
//Another advantage of making data members private is that the data are protected from mistakes that users might introduce. If there is a bug that corrupts an object’s state, the places to look for the bug are localized: Only code that is part of the implementation could be responsible for the error. The search for the mistake is limited, greatly easing the problems of maintenance and program correctness.

//Although user code need not change when a class definition changes, the source files that use a class must be recompiled anytime the class changes.

//Declarations for Friends

//A friend declaration only specifies access. It is not a general declaration of the function. If we want users of the class to be able to call a friend function, then we must also declare the function separately from the friend declaration.
//To make a friend visible to users of the class, we usually declare each friend (outside the class) in the same header as the class itself. Thus, our Sales_data header should provide separate declarations (aside from the friend declarations inside the class body) for read, print, and add.

//Some compilers allow calls to a friend function when there is no ordinary declaration for that function. Even if your compiler allows such calls, it is a good idea to provide separate declarations for friends. That way you won’t have to change your code if you use a compiler that enforces this rule.

//7.3 Additional Class Features

//7.3.1 Class Members Revisited

//In addition to defining data and function members, a class can define its own local names for types. Type names defined by a class are subject to the same access controls as any other member and may be either public or private:
class Screen {
  public:
    typedef std::string::size_type pos;
  private:
	pos cursor = 0;
	pos height = 0, width = 0;
	std::string contents;
};

//Unlike ordinary members, members that define types must appear before they are used. As a result, type members usually appear at the beginning of the class.

//Member functions defined inside the class are automatically inline.
//We can explicitly declare a member function as inline as part of its declaration inside the class body. Alternatively, we can specify inline on the function definition that appears outside the class body.
//Although we are not required to do so, it is legal to specify inline on both the declaration and the definition. However, specifying inline only on the definition outside the class can make the class easier to read.

//For the same reasons that we define inline functions in headers, inline member functions should be defined in the same header as the corresponding class definition.

//mutable Data Members
//It sometimes (but not very often) happens that a class has a data member that we want to be able to modify, even inside a const member function. We indicate such members by including the mutable keyword in their declaration.
//A mutable data member is never const, even when it is a member of a const object. Accordingly, a const member function may change a mutable member.
class Screen {
  public:
	void some_member() const;
  private:
	mutable size_t access_ctr; // may change even in a const object
// other members as before
};
void Screen::some_member() const {
    ++access_ctr; // keep a count of the calls to any member function
	// whatever other work this member needs to do
}
//Despite the fact that some_member is a const member function, it can change the value of access_ctr. That member is a mutable member, so any member function, including const functions, can change its value.

//Initializers for Data Members of Class Type
//Under the new standard, we can specify this default value using an in-class initializer.
//As we’ve seen, in-class initializers must use either the = form of initialization (which we used when we initialized the the data members of Screen) or the direct form of initialization using curly braces (as we do for screens).
//When we provide an in-class initializer, we must do so following an = sign or inside braces.

//7.3.2 Functions That Return *this

//Functions that return a reference are lvalues, which means that they return the object itself, not a copy of the object.

//Returning *this from a const Member Function
//A const member function that returns *this as a reference should have a return type that is a reference to const.

//Overloading Based on const
//We can overload a member function based on whether it is const for the same reasons that we can overload a function based on whether a pointer parameter points to const. The nonconst version will not be viable for const objects; we can only call const member functions on a const object. We can call either version on a nonconst object, but the nonconst version will be a better match.

//In this example, we’ll define a private member named do_display to do the actual work of printing the Screen. Each of the display operations will call this function and then return the object on which it is executing:
class Screen {
  public:
	// display overloaded on whether the object is const or not
	Screen &display(std::ostream &os) { do_display(os); return *this; }
	const Screen &display(std::ostream &os) const { do_display(os); return *this; }
  private:
	// function to do the work of displaying a Screen
	void do_display(std::ostream &os) const {os << contents;}
	// other members as before
};
//As in any other context, when one member calls another the this pointer is passed implicitly. Thus, when display calls do_display, its own this pointer is implicitly passed to do_display. When the nonconst version of display calls do_display, its this pointer is implicitly converted from a pointer to nonconst to a pointer to const.
//When do_display completes, the display functions each return the object on which they execute by dereferencing this. In the nonconst version, this points to a nonconst object, so that version of display returns an ordinary (nonconst) reference; the const member returns a reference to const.

//Advice: Use Private Utility Functions for Common Code Some readers might be surprised that we bothered to define a separate do_display operation. After all, the calls to do_display aren’t much simpler than the action done inside do_display. Why bother? We do so for several reasons:
//A general desire to avoid writing the same code in more than one place.
//We expect that the display operation will become more complicated as our class evolves. As the actions involved become more complicated, it makes more obvious sense to write those actions in one place, not two.
//It is likely that we might want to add debugging information to do_display during development that would be eliminated in the final product version of the code. It will be easier to do so if only one definition of do_display needs to be changed to add or remove the debugging code.
//There needn’t be any overhead involved in this extra function call. We defined do_display inside the class body, so it is implicitly inline. Thus, there likely be no run-time overhead associating with calling do_display.
//In practice, well-designed C++ programs tend to have lots of small functions such as do_display that are called to do the “real” work of some other set of functions.

//Class Types

//Every class defines a unique type. Two different classes define two different types even if they define the same members.
//Even if two classes have exactly the same member list, they are different types. The members of each class are distinct from the members of any other class (or any other scope).
//We can refer to a class type directly, by using the class name as a type name. Alternatively, we can use the class name following the keyword class or struct.
Sales_data item1; // default-initialized object of type Sales_data
class Sales_data item1; // equivalent declaration
//Both methods of referring to a class type are equivalent. The second method is inherited from C and is also valid in C++.

//Class declarations

//Just as we can declare a function apart from its definition (§ 6.1.2, p. 206), we can also declare a class without defining it:
class Screen; // declaration of the Screen class
//This declaration, sometimes referred to as a forward declaration, introduces the name Screen into the program and indicates that Screen refers to a class type. After a declaration and before a definition is seen, the type Screen is an incomplete type—it’s known that Screen is a class type but not known what members that type contains.

//We can use an incomplete type in only limited ways: We can define pointers or references to such types, and we can declare (but not define) functions that use an incomplete type as a parameter or return type.
//A class must be defined—not just declared—before we can write code that creates objects of that type. Otherwise, the compiler does not know how much storage such objects need. Similarly, the class must be defined before a reference or pointer is used to access a member of the type. After all, if the class has not been defined, the compiler can’t know what members the class has.

//With one exception that we’ll describe in § 7.6 (p. 300), data members can be specified to be of a class type only if the class has been defined. The type must be complete because the compiler needs to know how much storage the data member requires. Because a class is not defined until its class body is complete, a class cannot have data members of its own type. However, a class is considered declared (but not yet defined) as soon as its class name has been seen. Therefore, a class can have data members that are pointers or references to its own type:
class Link_screen {
	Screen window;
	Link_screen *next;
	Link_screen *prev;
};

//7.3.4 Friendship Revisited
//A class can make another class its friend or it can declare specific member functions of another (previously defined) class as friend. In addition, a friend function can be defined inside the class body. Such functions are implicitly inline.

//Friendship between Classes
class Screen {
	// Window_mgr members can access the private parts of class Screen
	friend class Window_mgr;
	// ... rest of the Screen class
};
//The member functions of a friend class can access all the members, including the nonpublic members, of the class granting friendship.

//It is important to understand that friendship is not transitive. That is, if class Window_mgr has its own friends, those friends have no special access to Screen.

//Each class controls which classes or functions are its friends.

//Making a Member Function a Friend

//When we declare a member function to be a friend, we must specify the class of which that function is a member:
class Screen {
	// Window_mgr::clear must have been declared before class Screen
	friend void Window_mgr::clear(ScreenIndex);
	// ... rest of the Screen class
};

//Making a member function a friend requires careful structuring of our programs to accommodate interdependencies among the declarations and definitions. In this example, we must order our program as follows:
//First, define the Window_mgr class, which declares, but cannot define, clear. Screen must be declared before clear can use the members of Screen.
//Next, define class Screen, including a friend declaration for clear.
//Finally, define clear, which can now refer to the members in Screen.

//Overloaded Functions and Friendship
//Although overloaded functions share a common name, they are still different functions. Therefore, a class must declare as a friend each function in a set of overloaded functions that it wishes to make a friend.

//Friend Declarations and Scope

//Classes and nonmember functions need not have been declared before they are used in a friend declaration. When a name first appears in a friend declaration, that name is implicitly assumed to be part of the surrounding scope. However, the friend itself is not actually declared in that scope.
//Even if we define the function inside the class, we must still provide a declaration outside of the class itself to make that function visible. A declaration must exist even if we only call the friend from members of the friendship granting class.
//It is important to understand that a friend declaration affects access but is not a declaration in an ordinary sense.
//Remember, some compilers do not enforce the lookup rules for friends.

//7.4 Class Scope

//Every class defines its own new scope. Outside the class scope, ordinary data and function members may be accessed only through an object, a reference, or a pointer using a member access operator. We access type members from the class using the scope operator . In either case, the name that follows the operator must be a member of the associated class.

//Scope and Members Defined outside the Class
//The fact that a class is a scope explains why we must provide the class name as well as the function name when we define a member function outside its class. Outside of the class, the names of the members are hidden.
//Once the class name is seen, the remainder of the definition—including the parameter list and the function body—is in the scope of the class. As a result, we can refer to other class members without qualification.

//On the other hand, the return type of a function normally appears before the function’s name. When a member function is defined outside the class body, any name used in the return type is outside the class scope. As a result, the return type must specify the class of which it is a member.

//7.4.1 Name Lookup and Class Scope

//In the programs we’ve written so far, name lookup (the process of finding which declarations match the use of a name) has been relatively straightforward:
//First, look for a declaration of the name in the block in which the name was used. Only names declared before the use are considered.
//If the name isn’t found, look in the enclosing scope(s).
//If no declaration is found, then the program is in error.
//The way names are resolved inside member functions defined inside the class may seem to behave differently than these lookup rules. However, in this case, appearances are deceiving. Class definitions are processed in two phases:
//First, the member declarations are compiled.
//Function bodies are compiled only after the entire class has been seen.

//Member function definitions are processed after the compiler processes all of the declarations in the class.

//Classes are processed in this two-phase way to make it easier to organize class code. Because member function bodies are not processed until the entire class is seen, they can use any name defined inside the class. If function definitions were processed at the same time as the member declarations, then we would have to order the member functions so that they referred only to names already seen.

//Name Lookup for Class Member Declarations
//This two-step process applies only to names used in the body of a member function. Names used in declarations, including names used for the return type and types in the parameter list, must be seen before they are used. If a member declaration uses a name that has not yet been seen inside the class, the compiler will look for that name in the scope(s) in which the class is defined.

//Type Names are Special
//Ordinarily, an inner scope can redefine a name from an outer scope even if that name has already been used in the inner scope. However, in a class, if a member uses a name from an outer scope and that name is a type, then the class may not subsequently redefine that name.
typedef double Money;
class Account {
  public:
	Money balance() { return bal; } // uses Money from the outerscope
  private:
	typedef double Money; // error: cannot redefine Money
	Money bal;
	// ...
};
//It is worth noting that even though the definition of Money inside Account uses the same type as the definition in the outer scope, this code is still in error.
//Although it is an error to redefine a type name, compilers are not required to diagnose this error. Some compilers will quietly accept such code, even though the program is in error.

//Definitions of type names usually should appear at the beginning of a class. That way any member that uses that type will be seen after the type name has already been defined.

//Normal Block-Scope Name Lookup inside Member Definitions
//A name used in the body of a member function is resolved as follows:
//First, look for a declaration of the name inside the member function. As usual, only declarations in the function body that precede the use of the name are considered.
//If the declaration is not found inside the member function, look for a declaration inside the class. All the members of the class are considered.
//If a declaration for the name is not found in the class, look for a declaration that is in scope before the member function definition.

//Ordinarily, it is a bad idea to use the name of another member as the name for a parameter in a member function.

//Even though the class member is hidden, it is still possible to use that member by qualifying the member’s name with the name of its class or by using the this pointer explicitly.
//Even though the outer object is hidden, it is still possible to access that object by using the scope operator.

//Names are Resolved Where They Appear within a File

//7.5 Constructors Revisited

//7.5.1 Constructor Initializer List

//When we define variables, we typically initialize them immediately rather than defining them and then assigning to them.

//Exactly the same distinction between initialization and assignment applies to the data members of objects. If we do not explicitly initialize a member in the constructor initializer list, that member is default initialized before the constructor body starts executing.
// legal but sloppier way to write the Sales_data constructor: no constructor initializers
Sales_data::Sales_data(const string &s, unsigned cnt, double price) {
	bookNo = s;
	units_sold = cnt;
	revenue = cnt * price;
}
//This version and our original definition on page 264 have the same effect: When the constructor finishes, the data members will hold the same values. The difference is that the original version initializes its data members, whereas this version assigns values to the data members. How significant this distinction is depends on the type of the data member.

//Constructor Initializers are Sometimes Required
//We can often, but not always, ignore the distinction between whether a member is initialized or assigned. Members that are const or references must be initialized. Similarly, members that are of a class type that does not define a default constructor also must be initialized. For example:
class ConstRef {
  public:
	ConstRef(int ii);
  private:
	int i;
	const int ci;
	int &ri;
};
//Like any other const object or reference, the members ci and ri must be initialized. As a result, omitting a constructor initializer for these members is an error:
// error: ci and ri must be initialized
ConstRef::ConstRef(int ii){ // assignments:
	i = ii; // ok
	ci = ii; // error: cannot assign to a const
	ri = i; // error: ri was never initialized
}
//By the time the body of the constructor begins executing, initialization is complete. Our only chance to initialize const or reference data members is in the constructor initializer. The correct way to write this constructor is
// ok: explicitly initialize reference and const members
ConstRef::ConstRef(int ii): i(ii), ci(ii), ri(i) { }

//Note: We must use the constructor initializer list to provide values for members that are const, reference, or of a class type that does not have a default constructor.

//Advice: Use Constructor Initializers
//In many classes, the distinction between initialization and assignment is strictly a matter of low-level efficiency: A data member is initialized and then assigned when it could have been initialized directly.
//More important than the efficiency issue is the fact that some data members must be initialized. By routinely using constructor initializers, you can avoid being surprised by compile-time errors when you have a class with a member that requires a constructor initializer.

//Order of Member Initialization
//What may be more surprising is that the constructor initializer list specifies only the values used to initialize the members, not the order in which those initializations are performed.
//Members are initialized in the order in which they appear in the class definition: The first member is initialized first, then the next, and so on. The order in which initializers appear in the constructor initializer list does not change the order of initialization.
//The order of initialization often doesn’t matter. However, if one member is initialized in terms of another, then the order in which members are initialized is crucially important.

//Some compilers are kind enough to generate a warning if the data members are listed in the constructor initializer in a different order from the order in which the members are declared.
//Best Practices: It is a good idea to write constructor initializers in the same order as the members are declared. Moreover, when possible, avoid using members to initialize other members.

//Default Arguments and Constructors
//A constructor that supplies default arguments for all its parameters also defines the default constructor.

//7.5.2 Delegating Constructors
//The new standard extends the use of constructor initializers to let us define so-called delegating constructors. A delegating constructor uses another constructor from its own class to perform its initialization. It is said to “delegate” some (or all) of its work to this other constructor.
//Like any other constructor, a delegating constructor has a member initializer list and a function body. In a delegating constructor, the member initializer list has a single entry that is the name of the class itself. Like other member initializers, the name of the class is followed by a parenthesized list of arguments. The argument list must match another constructor in the class.
class Sales_data {
  public:
	// nondelegating constructor initializes members from corresponding arguments
	Sales_data(std::string s, unsigned cnt, double price):
	bookNo(s), units_sold(cnt), revenue(cnt*price) { }
	// remaining constructors all delegate to another constructor
	Sales_data(): Sales_data("", 0, 0) {}
	Sales_data(std::string s): Sales_data(s, 0,0) {}
	Sales_data(std::istream &is): Sales_data() { read(is, *this); }
	// other members as before
};
//In this version of Sales_data, all but one of the constructors delegate their work. The first constructor takes three arguments, uses those arguments to initialize the data members, and does no further work. In this version of the class, we define the default constructor to use the three-argument constructor to do its initialization. It too has no additional work, as indicated by the empty constructor body. The constructor that takes a string also delegates to the three-argument version.
//The constructor that takes an istream& also delegates. It delegates to the default constructor, which in turn delegates to the three-argument constructor. Once those constructors complete their work, the body of the istream& constructor is run. Its constructor body calls read to read the given istream.
//When a constructor delegates to another constructor, the constructor initializer list and function body of the delegated-to constructor are both executed. In Sales_data, the function bodies of the delegated-to constructors happen to be empty. Had the function bodies contained code, that code would be run before control returned to the function body of the delegating constructor.






