//Chapter06

//Chapter 6 Functions

//6.1 Function Basics

//A function definition typically consists of a return type, a name, a list of zero or more parameters, and a body. The parameters are specified in a comma-separated list enclosed in parentheses. The actions that the function performs are specified in a statement block, referred to as the function body.
//We execute a function through the call operator, which is a pair of parentheses. The call operator takes an expression that is a function or points to a function. Inside the parentheses is a comma-separated list of arguments. The arguments are used to initialize the function’s parameters. The type of a call expression is the return type of the function.

//A function call does two things: It initializes the function's parameters from the corresponding arguments, and it transfers control to that function. Execution of the calling function is suspended and execution of the called function begins.
//Execution of a function begins with the (implicit) definition and initialization of its parameters.
//Execution of a function ends when a return statement is encountered. Like a function call, the return statement does two things: It returns the value (if any) in the return, and it transfers control out of the called function back to the calling function. The value returned by the function is used to initialize the result of the call expression. Execution continues with whatever remains of the expression in which the call appeared.

//Parameters and Arguments
//Arguments are the initializers for a function’s parameters. The first argument initializes the first parameter, the second argument initializes the second parameter, and so on. Although we know which argument initializes which parameter, we have no guarantees about the order in which arguments are evaluated. The compiler is free to evaluate the arguments in whatever order it prefers.
//The type of each argument must match the corresponding parameter in the same way that the type of any initializer must match the type of the object it initializes. We must pass exactly the same number of arguments as the function has parameters. Because every call is guaranteed to pass as many arguments as the function has parameters, parameters are always initialized.

//Function Parameter List
//A function’s parameter list can be empty but cannot be omitted. Typically we define a function with no parameters by writing an empty parameter list. For compatibility with C, we also can use the keyword void to indicate that there are no parameters:
void f1(){ /* ... */ } // implicit void parameter list
void f2(void){ /* ... */ } // explicit void parameter list

//Even when the types of two parameters are the same, the type must be repeated.

//Parameter names are optional. However, there is no way to use an unnamed parameter. Therefore, parameters ordinarily have names. Occasionally a function has a parameter that is not used. Such parameters are often left unnamed, to indicate that they aren’t used. Leaving a parameter unnamed doesn’t change the number of arguments that a call must supply. A call must supply an argument for every parameter, even if that parameter isn’t used.

//Function Return Type
//Most types can be used as the return type of a function. In particular, the return type can be void, which means that the function does not return a value. However, the return type may not be an array type or a function type. However, a function may return a pointer to an array or a function.

//6.1.1 Local Objects

//In C++, names have scope, and objects have lifetimes. IT is important to understand both of these concepts:
//The scope of a name is the part of the program’s text in which that name is visible.
//The lifetime of an object is the time during the program’s execution that the object exists.

//As we’ve seen, the body of a function is a statement block. As usual, the block forms a new scope in which we can define variables. Parameters and variables defined inside a function body are referred to as local variables. They are “local” to that function and hide declarations of the same name made in an outer scope.

//As we’ve seen, the body of a function is a statement block. As usual, the block forms a new scope in which we can define variables. Parameters and variables defined inside a function body are referred to as local variables. They are “local” to that function and hide declarations of the same name made in an outer scope.

//Automatic Objects
//The objects that correspond to ordinary local variables are created when the function’s control path passes through the variable’s definition. They are destroyed when control passes through the end of the block in which the variable is defined. Objects that exist only while a block is executing are known as automatic objects. After execution exits a block, the values of the automatic objects created in that block are undefined.
//Parameters are automatic objects. Storage for the parameters is allocated when the function begins. Parameters are defined in the scope of the function body. Hence they are destroyed when the function terminates.
//Automatic objects corresponding to the function’s parameters are initialized by the arguments passed to the function. Automatic objects corresponding to local variables are initialized if their definition contains an initializer. Otherwise, they are default initialized, which means that uninitialized local variables of built-in type have undefined values.

//Local Static Objects
//It can be useful to have a local variable whose lifetime continues across calls to the function. We obtain such objects by defining a local variable as static. Each local static object is initialized before the first time execution passes through the object’s definition. Local statics are not destroyed when a function ends; they are destroyed when the program terminates.

//If a local static has no explicit initializer, it is value initialized, meaning that local statics of built-in type are initialized to zero.

//6.1.2 Function Declarations

//Like any other name, the name of a function must be declared before we can use it. As with variables, a function may be defined only once but may be declared multiple times. With one exception, we can declare a function that is not defined so long as we never use that function.
//A function declaration is just like a function definition except that a declaration has no function body. In a declaration, a semicolon replaces the function body.
//Because a function declaration has no body, there is no need for parameter names. Hence, parameter names are often omitted in a declaration. Although parameter names are not required, they can be used to help users of the function understand what the function does.

//These these elements - the return type, function name, and parameter types - describe the function's interface. They specify all the information we need to call the function. Function declarations are also known as the function prototype.

//Recall that variables are declared in header files and defined in source files. For the same reasons, functions should be declared in header files and defined in source files.

//It may be tempting—and would be legal—to put a function declaration directly in each source file that uses the function. However, doing so is tedious and error-prone. When we use header files for our function declarations, we can ensure that all the declarations for a given function agree. Moreover, if the interface to the function changes, only one declaration has to be changed.

//The source file that defines a function should include the header that contains that function’s declaration. That way the compiler will verify that the definition and declaration are consistent.

//6.1.3 Separate Compilation

//As our programs get more complicated, we’ll want to store the various parts of the program in separate files. To allow programs to be written in logical parts, C++ supports what is commonly known as separate compilation. Separate compilation lets us split our programs into several files, each of which can be compiled independently.

//6.2 Argument Passing

//As we have seen, each time we call a function, its parameter are created and initialized by the arguments passed in the call.
//Parameter initialization works the same way as variable initialization.

//As with any other variable, the type of a parameter determines the interaction between the parameter and its argument. If the parameter is a reference, then the parameter is bound to its argument. Otherwise, the argument’s value is copied.

//When a parameter is a reference, we say that its corresponding argument is “passed by reference” or that the function is “called by reference.” As with any other reference, a reference parameter is an alias for the object to which it is bound; that is, the parameter is an alias for its corresponding argument.
//When the argument value is copied, the parameter and argument are independent objects. We say such arguments are “passed by value” or alternatively that the function is “called by value.”

//6.2.1 Passing Arguments by Value

//When we initialize a nonreference type variable, the value of the initializer is copied. Changes made to the variable have no effect on the initializer.

//Pointers behave like any other nonreference type. When we copy a pointer, the value of the pointer is copied. After the copy, the two pointers are distinct. However, a pointer also gives us indirect access to the object to which that pointer points. We can change the value of that object by assigning through the pointer.

//Programmers accustomed to programming in C often use pointer parameters to access objects outside a function. In C++, programmers generally use reference parameters instead.

//6.2.2 Passing Arguments by Reference

//Recall that operations on a reference are actually operations on the object to which the reference refers.

//Reference parameters that are not changed inside a function should be references to const.

//A function can return only a single value. However, sometimes a function has more than one value to return. Reference parameters let us effectively return multiple results.

//6.2.3 const Parameters and Arguments

//Just as in any other initialization, when we copy an argument to initialize a parameter, top-level consts are ignored. As a result, top-level const on parameters are ignored. We can pass either a const or a nonconst object to a parameter that has a top-level const:
void fcn(const int i) { /* fcn can read but not write to i */ }

//We can call fcn passing it either a const int or a plain int. The fact that top-level consts are ignored on a parameter has one possibly surprising implication:
void fcn(const int i) { /* fcn can read but not write to i */ }
void fcn(int i) { /* . . . */ } // error: redefines fcn(int)
//In C++, we can define several different functions that have the same name. However, we can do so only if their parameter lists are sufficiently different. Because top-level consts are ignored, we can pass exactly the same types to either version of fcn. The second version of fcn is an error. Despite appearances, its parameter list doesn’t differ from the list in the first version of fcn.

//Pointer or Reference Parameters and const

//Because parameters are initialized in the same way that variables are initialized, it can be helpful to remember the general initialization rules. We can initialize an object with a low-level const from a nonconst object but not vice versa, and a plain reference must be initialized from an object of the same type.
int i = 42;
const int *cp = &i; // ok: but cp can't change i 
const int &r = i; // ok: but r can't change i
const int &r2 = 42; // ok:
int *p = cp; // error: types of p and cp don't match 
int &r3 = r; // error: types of r3 and r don't match 
int &r4 = 42; // error: can't initialize a plain reference from a literal
//Exactly the same initialization rules apply to parameter passing:
int i = 0;
const int ci = i;
string::size_type ctr = 0;
reset(&i); // calls the version of reset that has an int* parameter
reset(&ci); // error: can't initialize an int* from a pointer to a const int object
reset(i); // calls the version of reset that has an int& parameter
reset(ci); // error: can't bind a plain reference to the const object ci
reset(42); // error: can't bind a plain reference to a literal
reset(ctr); // error: types don't match; ctr has an unsigned type
// ok: find_char's first parameter is a reference to const
find_char("Hello World!", 'o', ctr);
//We can call the reference version of reset only on int objects. We cannot pass a literal, an expression that evaluates to an int, an object that requires conversion, or a const int object. Similarly, we may pass only an int* to the pointer version of reset. On the other hand, we can pass a string literal as the first argument to find_char. That function’s reference parameter is a reference to const, and we can initialize references to const from literals.

//Use Reference to const When Possible

//It is a somewhat common mistake to define parameters that a function does not change as (plain) references. Doing so gives the function’s caller the misleading impression that the function might change its argument’s value. Moreover, using a reference instead of a reference to const unduly limits the type of arguments that can be used with the function. As we’ve just seen, we cannot pass a const object, or a literal, or an object that requires conversion to a plain reference parameter.

//6.2.4 Array Parameters

//Arrays have two special properties that affect how we define and use functions that operate on arrays: We cannot copy an array, and when we use an array it is (usually) converted to a pointer. Because we cannot copy an array, we cannot pass an array by value. Because arrays are converted to pointers, when we pass an array to a function, we are actually passing a pointer to the array’s first element.

//Even though we cannot pass an array by value, we can write a parameter that looks like an array:
// despite appearances, these three declarations of print are equivalent
// each function has a single parameter of type const int*
void print(const int*);
void print(const int[]); // shows the intent that the function takes an array
void print(const int[10]); // dimension for documentation purposes (at best)
//Regardless of appearances, these declaration are equivalent: Each declares a function with a single parameter of type const int*. When the compiler checks a call to print, it checks only that the argument has type const int*.
int i = 0, j[2] = {0, 1};
print(&i); // ok: &i is int*
print(j); // ok: j is converted to an int* that points to j[0]
//If we pass an array to print, that argument is automatically converted to a pointer to the first element in the array; the size of the array is irrelevant.

//As with any code that uses arrays, functions that take array parameters must ensure that all uses of the array stay within the array bounds.

//Because arrays are passed as pointers, functions ordinarily don’t know the size of the array they are given. They must rely on additional information provided by the caller. There are three common techniques used to manage pointer parameters.

//Using a Marker to Specify the Extent of an Array
//The first approach to managing array arguments requires the array itself to contain an end marker. C-style character strings are an example of this approach. C-style strings are stored in character arrays in which the last character of the string is followed by a null character. Functions that deal with C-style strings stop processing the array when they see a null character.

//Using the Standard Library Conventions
//A second technique used to manage array arguments is to pass pointers to the first and one past the last element in the array. This approach is inspired by techniques used in the standard library.

//Explicitly Passing a Size Parameter
//A third approach for array arguments, which is common in C programs and older C++ programs, is to define a second parameter that indicates the size of the array.

//Array Parameters and const
//When a function does not need write access to the array elements, the array parameter should be a pointer to const. A parameter should be a plain pointer to a nonconst type only if the function needs to change element values.

f(int &arr[10]) // error: declares arr as an array of references
f(int (&arr)[10]) // ok: arr is a reference to an array of ten ints

//Passing a Multidimensional Array
//Recall that there are no multidimensional arrays in C++. Instead, what appears to be a multidimensional array is an array of arrays.
//As with any array, a multidimensional array is passed as a pointer to its first element. Because we are dealing with an array of arrays, that element is an array, so the pointer is a pointer to an array. The size of the second (and any subsequent) dimension is part of the element type and must be specified:
// matrix points to the first element in an array whose elements are arrays of ten ints
void print(int (*matrix)[10], int rowSize) { /* . . . */ }
//declares matrix as a pointer to an array of ten ints.
//Again, the parentheses around *matrix are necessary:
int *matrix[10]; // array of ten pointers
int (*matrix)[10]; // pointer to an array of ten ints

//We can also define our function using array syntax. As usual, the compiler ignores the first dimension, so it is best not to include it:
// equivalent definition
void print(int matrix[][10], int rowSize) { /* . . . */ }
//declares matrix to be what looks like a two-dimensional array. In fact, the parameter is a pointer to an array of ten ints.

//6.2.5 main: Handling Command-Line Options



