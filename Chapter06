//Chapter06

//Chapter 6 Functions

//6.1 Function Basics

//A function definition typically consists of a return type, a name, a list of zero or more parameters, and a body. The parameters are specified in a comma-separated list enclosed in parentheses. The actions that the function performs are specified in a statement block, referred to as the function body.
//We execute a function through the call operator, which is a pair of parentheses. The call operator takes an expression that is a function or points to a function. Inside the parentheses is a comma-separated list of arguments. The arguments are used to initialize the function’s parameters. The type of a call expression is the return type of the function.

//A function call does two things: It initializes the function's parameters from the corresponding arguments, and it transfers control to that function. Execution of the calling function is suspended and execution of the called function begins.
//Execution of a function begins with the (implicit) definition and initialization of its parameters.
//Execution of a function ends when a return statement is encountered. Like a function call, the return statement does two things: It returns the value (if any) in the return, and it transfers control out of the called function back to the calling function. The value returned by the function is used to initialize the result of the call expression. Execution continues with whatever remains of the expression in which the call appeared.

//Parameters and Arguments
//Arguments are the initializers for a function’s parameters. The first argument initializes the first parameter, the second argument initializes the second parameter, and so on. Although we know which argument initializes which parameter, we have no guarantees about the order in which arguments are evaluated. The compiler is free to evaluate the arguments in whatever order it prefers.
//The type of each argument must match the corresponding parameter in the same way that the type of any initializer must match the type of the object it initializes. We must pass exactly the same number of arguments as the function has parameters. Because every call is guaranteed to pass as many arguments as the function has parameters, parameters are always initialized.

//Function Parameter List
//A function’s parameter list can be empty but cannot be omitted. Typically we define a function with no parameters by writing an empty parameter list. For compatibility with C, we also can use the keyword void to indicate that there are no parameters:
void f1(){ /* ... */ } // implicit void parameter list
void f2(void){ /* ... */ } // explicit void parameter list

//Even when the types of two parameters are the same, the type must be repeated.

//Parameter names are optional. However, there is no way to use an unnamed parameter. Therefore, parameters ordinarily have names. Occasionally a function has a parameter that is not used. Such parameters are often left unnamed, to indicate that they aren’t used. Leaving a parameter unnamed doesn’t change the number of arguments that a call must supply. A call must supply an argument for every parameter, even if that parameter isn’t used.

//Function Return Type
//Most types can be used as the return type of a function. In particular, the return type can be void, which means that the function does not return a value. However, the return type may not be an array type or a function type. However, a function may return a pointer to an array or a function.

//6.1.1 Local Objects

//In C++, names have scope, and objects have lifetimes. IT is important to understand both of these concepts:
//The scope of a name is the part of the program’s text in which that name is visible.
//The lifetime of an object is the time during the program’s execution that the object exists.

//As we’ve seen, the body of a function is a statement block. As usual, the block forms a new scope in which we can define variables. Parameters and variables defined inside a function body are referred to as local variables. They are “local” to that function and hide declarations of the same name made in an outer scope.

//As we’ve seen, the body of a function is a statement block. As usual, the block forms a new scope in which we can define variables. Parameters and variables defined inside a function body are referred to as local variables. They are “local” to that function and hide declarations of the same name made in an outer scope.

//Automatic Objects
//The objects that correspond to ordinary local variables are created when the function’s control path passes through the variable’s definition. They are destroyed when control passes through the end of the block in which the variable is defined. Objects that exist only while a block is executing are known as automatic objects. After execution exits a block, the values of the automatic objects created in that block are undefined.
//Parameters are automatic objects. Storage for the parameters is allocated when the function begins. Parameters are defined in the scope of the function body. Hence they are destroyed when the function terminates.
//Automatic objects corresponding to the function’s parameters are initialized by the arguments passed to the function. Automatic objects corresponding to local variables are initialized if their definition contains an initializer. Otherwise, they are default initialized, which means that uninitialized local variables of built-in type have undefined values.

//Local Static Objects
//It can be useful to have a local variable whose lifetime continues across calls to the function. We obtain such objects by defining a local variable as static. Each local static object is initialized before the first time execution passes through the object’s definition. Local statics are not destroyed when a function ends; they are destroyed when the program terminates.

//If a local static has no explicit initializer, it is value initialized, meaning that local statics of built-in type are initialized to zero.

//6.1.2 Function Declarations

//Like any other name, the name of a function must be declared before we can use it. As with variables, a function may be defined only once but may be declared multiple times. With one exception, we can declare a function that is not defined so long as we never use that function.
//A function declaration is just like a function definition except that a declaration has no function body. In a declaration, a semicolon replaces the function body.
//Because a function declaration has no body, there is no need for parameter names. Hence, parameter names are often omitted in a declaration. Although parameter names are not required, they can be used to help users of the function understand what the function does.

//These these elements - the return type, function name, and parameter types - describe the function's interface. They specify all the information we need to call the function. Function declarations are also known as the function prototype.

//Recall that variables are declared in header files and defined in source files. For the same reasons, functions should be declared in header files and defined in source files.

//It may be tempting—and would be legal—to put a function declaration directly in each source file that uses the function. However, doing so is tedious and error-prone. When we use header files for our function declarations, we can ensure that all the declarations for a given function agree. Moreover, if the interface to the function changes, only one declaration has to be changed.

//The source file that defines a function should include the header that contains that function’s declaration. That way the compiler will verify that the definition and declaration are consistent.

//6.1.3 Separate Compilation

//As our programs get more complicated, we’ll want to store the various parts of the program in separate files. To allow programs to be written in logical parts, C++ supports what is commonly known as separate compilation. Separate compilation lets us split our programs into several files, each of which can be compiled independently.

//6.2 Argument Passing

//As we have seen, each time we call a function, its parameter are created and initialized by the arguments passed in the call.
//Parameter initialization works the same way as variable initialization.

//As with any other variable, the type of a parameter determines the interaction between the parameter and its argument. If the parameter is a reference, then the parameter is bound to its argument. Otherwise, the argument’s value is copied.

//When a parameter is a reference, we say that its corresponding argument is “passed by reference” or that the function is “called by reference.” As with any other reference, a reference parameter is an alias for the object to which it is bound; that is, the parameter is an alias for its corresponding argument.
//When the argument value is copied, the parameter and argument are independent objects. We say such arguments are “passed by value” or alternatively that the function is “called by value.”

//6.2.1 Passing Arguments by Value

//When we initialize a nonreference type variable, the value of the initializer is copied. Changes made to the variable have no effect on the initializer.

//Pointers behave like any other nonreference type. When we copy a pointer, the value of the pointer is copied. After the copy, the two pointers are distinct. However, a pointer also gives us indirect access to the object to which that pointer points. We can change the value of that object by assigning through the pointer.

//Programmers accustomed to programming in C often use pointer parameters to access objects outside a function. In C++, programmers generally use reference parameters instead.

//6.2.2 Passing Arguments by Reference

//Recall that operations on a reference are actually operations on the object to which the reference refers.

//Reference parameters that are not changed inside a function should be references to const.

//A function can return only a single value. However, sometimes a function has more than one value to return. Reference parameters let us effectively return multiple results.

//6.2.3 const Parameters and Arguments

//Just as in any other initialization, when we copy an argument to initialize a parameter, top-level consts are ignored. As a result, top-level const on parameters are ignored. We can pass either a const or a nonconst object to a parameter that has a top-level const:
void fcn(const int i) { /* fcn can read but not write to i */ }

//We can call fcn passing it either a const int or a plain int. The fact that top-level consts are ignored on a parameter has one possibly surprising implication:
void fcn(const int i) { /* fcn can read but not write to i */ }
void fcn(int i) { /* . . . */ } // error: redefines fcn(int)
//In C++, we can define several different functions that have the same name. However, we can do so only if their parameter lists are sufficiently different. Because top-level consts are ignored, we can pass exactly the same types to either version of fcn. The second version of fcn is an error. Despite appearances, its parameter list doesn’t differ from the list in the first version of fcn.

//Pointer or Reference Parameters and const

//Because parameters are initialized in the same way that variables are initialized, it can be helpful to remember the general initialization rules. We can initialize an object with a low-level const from a nonconst object but not vice versa, and a plain reference must be initialized from an object of the same type.
int i = 42;
const int *cp = &i; // ok: but cp can't change i 
const int &r = i; // ok: but r can't change i
const int &r2 = 42; // ok:
int *p = cp; // error: types of p and cp don't match 
int &r3 = r; // error: types of r3 and r don't match 
int &r4 = 42; // error: can't initialize a plain reference from a literal
//Exactly the same initialization rules apply to parameter passing:
int i = 0;
const int ci = i;
string::size_type ctr = 0;
reset(&i); // calls the version of reset that has an int* parameter
reset(&ci); // error: can't initialize an int* from a pointer to a const int object
reset(i); // calls the version of reset that has an int& parameter
reset(ci); // error: can't bind a plain reference to the const object ci
reset(42); // error: can't bind a plain reference to a literal
reset(ctr); // error: types don't match; ctr has an unsigned type
// ok: find_char's first parameter is a reference to const
find_char("Hello World!", 'o', ctr);
//We can call the reference version of reset only on int objects. We cannot pass a literal, an expression that evaluates to an int, an object that requires conversion, or a const int object. Similarly, we may pass only an int* to the pointer version of reset. On the other hand, we can pass a string literal as the first argument to find_char. That function’s reference parameter is a reference to const, and we can initialize references to const from literals.

//Use Reference to const When Possible

//It is a somewhat common mistake to define parameters that a function does not change as (plain) references. Doing so gives the function’s caller the misleading impression that the function might change its argument’s value. Moreover, using a reference instead of a reference to const unduly limits the type of arguments that can be used with the function. As we’ve just seen, we cannot pass a const object, or a literal, or an object that requires conversion to a plain reference parameter.

//6.2.4 Array Parameters

//Arrays have two special properties that affect how we define and use functions that operate on arrays: We cannot copy an array, and when we use an array it is (usually) converted to a pointer. Because we cannot copy an array, we cannot pass an array by value. Because arrays are converted to pointers, when we pass an array to a function, we are actually passing a pointer to the array’s first element.

//Even though we cannot pass an array by value, we can write a parameter that looks like an array:
// despite appearances, these three declarations of print are equivalent
// each function has a single parameter of type const int*
void print(const int*);
void print(const int[]); // shows the intent that the function takes an array
void print(const int[10]); // dimension for documentation purposes (at best)
//Regardless of appearances, these declaration are equivalent: Each declares a function with a single parameter of type const int*. When the compiler checks a call to print, it checks only that the argument has type const int*.
int i = 0, j[2] = {0, 1};
print(&i); // ok: &i is int*
print(j); // ok: j is converted to an int* that points to j[0]
//If we pass an array to print, that argument is automatically converted to a pointer to the first element in the array; the size of the array is irrelevant.

//As with any code that uses arrays, functions that take array parameters must ensure that all uses of the array stay within the array bounds.

//Because arrays are passed as pointers, functions ordinarily don’t know the size of the array they are given. They must rely on additional information provided by the caller. There are three common techniques used to manage pointer parameters.

//Using a Marker to Specify the Extent of an Array
//The first approach to managing array arguments requires the array itself to contain an end marker. C-style character strings are an example of this approach. C-style strings are stored in character arrays in which the last character of the string is followed by a null character. Functions that deal with C-style strings stop processing the array when they see a null character.

//Using the Standard Library Conventions
//A second technique used to manage array arguments is to pass pointers to the first and one past the last element in the array. This approach is inspired by techniques used in the standard library.

//Explicitly Passing a Size Parameter
//A third approach for array arguments, which is common in C programs and older C++ programs, is to define a second parameter that indicates the size of the array.

//Array Parameters and const
//When a function does not need write access to the array elements, the array parameter should be a pointer to const. A parameter should be a plain pointer to a nonconst type only if the function needs to change element values.

f(int &arr[10]) // error: declares arr as an array of references
f(int (&arr)[10]) // ok: arr is a reference to an array of ten ints

//Passing a Multidimensional Array
//Recall that there are no multidimensional arrays in C++. Instead, what appears to be a multidimensional array is an array of arrays.
//As with any array, a multidimensional array is passed as a pointer to its first element. Because we are dealing with an array of arrays, that element is an array, so the pointer is a pointer to an array. The size of the second (and any subsequent) dimension is part of the element type and must be specified:
// matrix points to the first element in an array whose elements are arrays of ten ints
void print(int (*matrix)[10], int rowSize) { /* . . . */ }
//declares matrix as a pointer to an array of ten ints.
//Again, the parentheses around *matrix are necessary:
int *matrix[10]; // array of ten pointers
int (*matrix)[10]; // pointer to an array of ten ints

//We can also define our function using array syntax. As usual, the compiler ignores the first dimension, so it is best not to include it:
// equivalent definition
void print(int matrix[][10], int rowSize) { /* . . . */ }
//declares matrix to be what looks like a two-dimensional array. In fact, the parameter is a pointer to an array of ten ints.

//6.2.5 main: Handling Command-Line Options

int main(int argc, char *argv[]) {...}
//The second parameter, argv, is an array of pointers to C-style character strings. The first parameter, argc, passes the number of strings in that array. Because the second parameter is an array, we might alternatively define main as:
int main(int argc, char **argv) {...}
//indicating that argv points to a char*.

//When arguments are passed to main, the first element in argv points either to the name of the program or to the empty string. Subsequent elements pass the arguments provided on the command line. The element just past the last pointer is guaranteed to be 0.

//When you use the arguments in argv, remember that the optional arguments begin in argv[1]; argv[0] contains the program’s name, not user input.

//6.2.6 Functions with Varying Parameters

//The new standard provides two primary ways to write a function that takes a varying number of arguments: If all the arguments have the same type, we can pass a library type named initializer_list. If the argument types vary, we can write a special kind of function, known as a variadic template.

//C++ also has a special parameter type, ellipsis, that can be used to pass a varying number of arguments. We’ll look briefly at ellipsis parameters in this section. However, it is worth noting that this facility ordinarily should be used only in programs that need to interface to C functions.

//Initializer_list Parameters
//We can write a function that takes an unknown number of arguments of a single type by using an initializer_list parameter. An initializer_list is a library type that represents an array of values of the specified type. This type is defined in the initializer_list header.

initializer_list<T> lst;    //Default initialization; an empty list of elements of type T
initializer_list<T> lst{a, b, c};    //lst has as many elements as there are initializers, elements are copies of the corresponding initializer. Elements in the list are const.
lst2(lst);    lst2=lst;    //Copying or assigning an initializer_list does not copy the elements in the list. After the copy, the original and the copy share the elements
lst.size();    //Number of elements in the list
lst.begin();    list.end();    //Returns a pointer to the first and one past the last element in lst.

//The elements in an initializer_list are always const values; there is no way to change the value of an element in an initializer_list.

//When we pass a sequence of values to an initializer_list parameter, we must enclose the sequence in curly braces.

//Ellipsis Parameters
//Ellipsis parameters are in C++ to allow programs to interface to C code that uses a C library facility named varargs. Generally an ellipsis parameter should not be used for other purposes. Your C compiler documentation will describe how to use varargs.

//An ellipsis parameter may appear only as the last element in a parameter list and may take either of two forms:
void foo(parm_list, ...);
void foo(...);
//The first form specifies the type(s) for some of foo’s parameters. Arguments that correspond to the specified parameters are type checked as usual. No type checking is done for the arguments that correspond to the ellipsis parameter. In this first form, the comma following the parameter declarations is optional.

//6.3 Return Types and the return Statement

//A return statement terminates the function that is currently executing and returns control to the point from which the function was called. There are two forms of return statements:
return;
return expression;

//6.3.1 Functions with No Return Value

//A return with no value may be used only in a function that has a return type of void. Functions that return void are not required to contain a return. In a void function, an implicit return takes place after the function’s last statement.

//Typically, void functions use a return to exit the function at an intermediate point. This use of return is analogous to the use of a break statement to exit a loop.

//A function with a void return type may use the second form of the return statement only to return the result of calling another function that returns void. Returning any other expression from a void function is a compile-time error.

//6.3.2 Functions that Return a Value

//The second form of the return statement provides the function’s result. Every return in a function with a return type other than void must return a value. The value returned must have the same type as the function return type, or it must have a type that can be implicitly converted to that type.

//Although C++ cannot guarantee the correctness of a result, it can guarantee that every return includes a result of the appropriate type. Although it cannot do so in all cases, the compiler attempts to ensure that functions that return a value are exited only through a valid return statement.

//Failing to provide a return after a loop that contains a return is an error. However, many compilers will not detect such errors.

//How Values Are Returned
//Values are returned in exactly the same way as variables and parameters are initialized: The return value is used to initialize a temporary at the call site, and that temporary is the result of the function call. 

//Never Return a Reference or Pointer to a Local Object

//One good way to ensure that the return is safe is to ask: To what preexisting object is the reference referring?

//For the same reasons that it is wrong to return a reference to a local object, it is also wrong to return a pointer to a local object. Once the function completes, the local objects are freed. The pointer would point to a nonexistent object.

//Functions That Return Class Types and the Call Operator

//Like any operator the call operator has associativity and precedence. The call operator has the same precedence as the dot and arrow operators. Like those operators, the call operator is left associative. As a result, if a function returns a pointer, reference or object of class type, we can use the result of a call to call a member of the resulting object.

//Reference Returns are Lvalues

//Whether a function call is an lvalue depends on the return type of the function. Calls to functions that return references are lvalues; other return types yield rvalues. A call to a function that returns a reference can be used in the same ways as any other lvalue. In particular, we can assign to the result of a function that returns a reference to nonconst.
char &get_val(string &str, string::size_type ix) {
    return str[ix]; // get_val assumes the given index is valid
}
int main() {
    string s("a value");
    cout << s << endl; // prints a value
    get_val(s, 0) = 'A'; // changes s[0] to A
    cout << s << endl; // prints A value
    return 0;
}
//It may be surprising to see a function call on the left-hand side of an assignment. However, nothing special is involved. The return value is a reference, so the call is an lvalue. Like any other lvalue, it may appear as the left-hand operand of the assignment operator.
//If the return type is a reference to const, then (as usual) we may not assign to the result of the call.

//List Initializing the Return Value
//Under the new standard, functions can return a braced list of values. As in any other return, the list is used to initialize the temporary that represents the function’s return. If the list is empty, that temporary is value initialized. Otherwise, the value of the return depends on the function’s return type.

//In a function that returns a built-in type, a braced list may contain at most one value, and that value must not require a narrowing conversion. If the function returns a class type, then the class itself defines how the intiailizers are used.

//Return from main
//There is one exception to the rule that a function with a return type other than void must return a value: The main function is allowed to terminate without a return. If control reaches the end of main and there is no return, then the compiler implicitly inserts a return of 0.

//The value returned from main is treated as a status indicator. A zero return indicates success; most other values indicate failure. A nonzero value has a machine-dependent meaning. To make return values machine independent, the cstdlib header defines two preprocessor variables that we can use to indicate success or failure.
int main() {
    if (some_failure) return EXIT_FAILURE; // defined in cstdlib
    else return EXIT_SUCCESS; // defined in cstdlib
}
//Because these are preprocessor variables, we must not precede them with std::, nor may we mention them in using declarations.

//Recursion
//A function that calls itself, either directly or indirectly, is a recursive function. 

//6.3.3 Returning a Pointer to an Array

//Because we cannot copy an array, a function cannot return an array. However, a function can return a pointer of a reference to an array. Unfortunately, the syntax used to define functions that return pointers or references to arrays can be intimidating. Fortunately, there are ways to simplify such declarations. The most straightforward way is to use a type alias:
typedef int arrT[10];    // arrT is a synonym for the type array of ten ints
using arrtT = int[10];    // equivalent declaration of arrT; see § 2.5.1 (p. 68)
arrT* func(int i);    // func returns a pointer to an array of five ints
//Here arrT is a synonym for an array of ten ints. Because we cannot return an array, we define the return type as a pointer to this type. Thus, func is a function that takes a single int argument and returns a pointer to an array of ten ints.

//Declaring a Function that Returns a Pointer to an Array

//To declare func without using a type alias, we must remember that the dimension of an array follows the name being defined:
int arr[10]; // arr is an array of ten ints
int *p1[10]; // p1 is an array of ten pointers
int (*p2)[10] = &arr; // p2 points to an array of ten ints
//As with these declarations, if we want to define a function that returns a pointer to an array, the dimension must follow the function’s name. However, a function includes a parameter list, which also follows the name. The parameter list precedes the dimension. Hence, the form of a function that returns a pointer to an array is:
Type (*function(parameter_list))[dimension]

//As in any other array declaration, Type is the type of the elements and dimension is the size of the array. The parentheses around (*function (parameter_list)) are necessary for the same reason that they were required when we defined p2. Without them, we would be defining a function that returns an array of pointers.
//As a concrete example, the following declares func without using a type alias:
int (*func(int i))[10];
//To understand this declaration, it can be helpful to think about it as follows:
//func(int) says that we can call func with an int argument.
//(*func(int)) says we can dereference the result of that call.
//(*func(int))[10] says that dereferencing the result of a call to func yields an array of size ten.
//int (*func(int))[10] says the element type in that array is int.

//Using a Trailing Return Type
//Under the new standard, another way to simplify the declaration of func is by using a trailing return type. Trailing returns can be defined for any function, but are most useful for functions with complicated return types, such as pointers (or references) to arrays. A trailing return type follows the parameter list and is preceded by ->. To signal that the return follows the parameter list, we use auto where the return type ordinarily appears:
// fcn takes an int argument and returns a pointer to an array of ten ints
auto func(int i) -> int(*)[10];
//Because the return type comes after the parameter list, it is easier to see that func returns a pointer and that that pointer points to an array of ten ints.

//Using decltype
//As another alternative, if we know the array(s) to which our function can return a pointer, we can use decltype to declare the return type. For example, the following function returns a pointer to one of two arrays, depending on the value of its parameter:
int odd[] = {1,3,5,7,9};
int even[] = {0,2,4,6,8};
// returns a pointer to an array of five int elements
decltype(odd) *arrPtr(int i){
    return (i % 2) ? &odd : &even; // returns a pointer to the array
}
//The return type for arrPtr uses decltype to say that the function returns a pointer to whatever type odd has. That object is an array, so arrPtr returns a pointer to an array of five ints. The only tricky part is that we must remember that decltype does not automatically convert an array to its corresponding pointer type. The type returned by decltype is an array type, to which we must add a * to indicate that arrPtr returns a pointer.

//6.4 Overloaded Functions

//Functions that have the same name but different parameter lists and that appear in the same scope are overloaded.
//When we call the overloaded functions, compiler can deduce which function we want based on the argument type we pass.

//Defining Overloaded Functions

//Overloaded functions share the same name, yet they are distinct functions. The compiler uses the argument type(s) to figure out which function to call.
//Overloaded functions must differ in the number or the type(s) of their parameters.
//It is an error for two functions to differ only in terms of their return type. If the parameter lists of two functions match but the return types differ, then the second declaration is an error:
Record lookup(const Account&);
bool lookup(const Account&);    //error: only the return type is different

//Overloading and const Parameters

//As we saw in § 6.2.3 (p. 212), top-level const has no effect on the objects that can be passed to the function. A parameter that has a top-level const is indistinguishable from one without a top-level const:
Record lookup(Phone);
Record lookup(const Phone); // redeclares Record lookup(Phone)
Record lookup(Phone*);
Record lookup(Phone* const); // redeclares Record lookup(Phone*)
//In these declarations, the second declaration declares the same function as the first. On the other hand, we can overload based on whether the parameter is a reference (or pointer) to the const or nonconst version of a given type; such consts are low-level:
// functions taking const and nonconst references or pointers have different
parameters
// declarations for four independent, overloaded functions
Record lookup(Account&); // function that takes a reference to Account
Record lookup(const Account&); // new function that takes a const reference
Record lookup(Account*); // new function, takes a pointer to Account
Record lookup(const Account*); // new function, takes a pointer to const
//In these cases, the compiler can use the constness of the argument to distinguish which function to call. Because there is no conversion from const, we can pass a const object (or a pointer to const) only to the version with a const parameter. Because there is a conversion to const, we can call either function on a nonconst object or a pointer to nonconst. However, as we’ll see in § 6.6.1 (p. 246), the compiler will prefer the nonconst versions when we pass a nonconst object or pointer to nonconst.

//const_cast and Overloading
//We noted that const_cast are most useful in the context of overloaded functions. As one example, recall our shorterString function from §6.3.2 (p. 224):
// return a reference to the shorter of two strings
const string &shorterString(const string &s1, const string
&s2){
    return s1.size() <= s2.size() ? s1 : s2;
}
//This function takes and returns references to const string. We can call the function on a pair of nonconst string arguments, but we’ll get a reference to a const string as the result. We might want to have a version of shorterString that, when given nonconst arguments, would yield a plain reference. We can write this version of our function using a const_cast:
string &shorterString(string &s1, string &s2){
    auto &r = shorterString(const_cast<const string&>(s1),
    const_cast<const string&>(s2));
    return const_cast<string&>(r);
}
//This version calls the const version of shorterString by casting its arguments to references to const. That function returns a reference to a const string, which we know is bound to one of our original, nonconst arguments. Therefore, we know it is safe to cast that string back to a plain string& in the return.

//Calling an Overloaded Function

//Once we have defined a set of overloaded functions, we need to be able to call them with appropriate arguments. Function matching (also known as overload resolution) is the process by which a particular function call is associated with a specific function from a set of overloaded functions. The compiler determines which function to call by comparing the arguments in the call with the parameters offered by each function in the overload set.

//For now, what’s important to realize is that for any given call to an overloaded function, there are three possible outcomes:
//The compiler finds exactly one function that is a best match for the actual arguments and generates code to call that function.
//There is no function with parameters that match the arguments in the call, in which case the compiler issues an error message that there was no match.
//There is more than one function that matches and none of the matches is clearly best. This case is also an error; it is an ambiguous call.

//6.4.1 Overloading and Scope
//Ordinarily, it is a bad idea to declare a function locally.
//If we declare a name in an inner scope, that name hides uses of that name declared in an outer scope. Names do not overload across scopes.

//In C++, name lookup happens before type checking.

//6.5 Features for Specialized Uses

//6.5.1 Default Arguments

//Some functions have parameters that are given a particular value in most, but not all, calls. In such cases, we can declare that common value as a default argument for the function. Functions with default arguments can be called with or without that argument.
//A default argument is specified as an initializer for a parameter in the parameter list. We may define defaults for one or more parameters. However, if a parameter has a default argument, all the parameters that follow it must also have default arguments.

//Part of the work of designing a function with default arguments is ordering the parameters so that those least likely to use a default value appear first and those most likely to use a default appear last.

//Default Argument Declarations
//Although it is normal practice to declare a function once inside a header, it is legal to redeclare a function multiple times. However, each parameter can have its default specified only once in a given scope. Thus, any subsequent declaration can add a default only for a parameter that has not previously had a default specified. As usual, defaults can be specified only if all parameters to the right already have defaults.
//Default arguments ordinarily should be specified with the function declaration in an appropriate header.

//Default Argument Initializers
//Local variables may not be used as a default argument. Excepting that restriction, a default argument can be any expression that has a type that is convertible to the type of the parameter.

//6.5.2 Inline and constexpr Functions

//Calling a function is apt to be slower than evaluating the equivalent expression. On most machines, a function call does a lot of work: Registers are saved before the call and restored after the return; arguments may be copied; and the program branches to a new location.

//inline Functions Avoid Function Call Overhead
//A function specified as inline (usually) is expanded "in line" at each call.
//The runtime overhead of making (inline) a function is removed.

//The inline specification is only a request to the compiler. The compiler may choose to ignore this request.
//In general, the inline mechanism is meant to optimize small, straight-line functions that are called frequently. Many compilers will not inline a recursive function.

//constexpr Functions
//A constexpr function is a function that can be used in a constant expression. A constexpr function is defined like any other function but must meet certain restrictions: The return type and the type of each parameter in a must be a literal type, and the function body must contain exactly one return statement:
constexpr int new_sz() { return 42; }
constexpr int foo = new_sz(); // ok: foo is a constant expression
//Here we defined new_sz as a constexpr that takes no arguments. The compiler can verify—at compile time—that a call to new_sz returns a constant expression, so we can use new_sz to initialize our constexpr variable, foo.
//When it can do so, the compiler will replace a call to a constexpr function with its resulting value. In order to be able to expand the function immediately, constexpr functions are implicitly inline.

//A constexpr function body may contain other statements so long as those statements generate no actions at run time. For example, a constexpr function may contain null statements, type aliases, and using declarations. A constexpr function is permitted to return a value that is not a constant:
// scale(arg) is a constant expression if arg is a constant expression
constexpr size_t scale(size_t cnt) { return new_sz() * cnt; }
//The scale function will return a constant expression if its argument is a constant expression but not otherwise.

//When we pass a constant expression—such as the literal 2—then the return is a constant expression. In this case, the compiler will replace the call to scale with the resulting value.

//If we call scale with an expression that is not a constant expression—such as on the int object i—then the return is not a constant expression. If we use scale in a context that requires a constant expression, the compiler checks that the result is a constant expression. If it is not, the compiler will produce an error message.

//A constexpr function is not required to return a constant expression.

//Unlike other functions, inline and constexpr functions may be defined multiple times in the program. After all, the compiler needs the definition, not just the declaration, in order to expand the code. However, all of the definitions of a given inline or constexpr must match exactly. As a result, inline and constexpr functions normally are defined in headers.

//6.5.3 Aids for Debugging

//C++ programmers sometimes use a technique similar to header guards to conditionally execute debugging code. The idea is that the program will contain debugging code that is executed only while the program is being developed. When the application is completed and ready to ship, the debugging code is turned off. This approach uses two preprocessor facilities: assert and NDEBUG.

//The assert Preprocessor Macro

//assert is a preprocessor macro. A preprocessor macro is a preprocessor variable that acts somewhat like an inline function. The assert macro takes a single expression, which it uses as a condition:
assert(expr);
//evaluates expr and if the expression is false (i.e., zero), then assert writes a message and terminates the program. If the expression is true (i.e., is nonzero), then assert does nothing.

//The NDEBUG Processor Variable

//The behavior of assert depends on the status of a preprocessor variable named NDEBUG. If NDEBUG is defined, assert does nothing. By default, NDEBUG is not defined, so, by default, assert performs a run-time check.
//We can “turn off” debugging by providing a #define to define NDEBUG. Alternatively, most compilers provide a command-line option that lets us define preprocessor variables:
$ CC -D NDEBUG main.C # use /D with the Microsoft compiler
//has the same effect as writing #define NDEBUG at the beginning of main.C.

//If NDEBUG is defined, we avoid the potential run-time overhead involved in checking various conditions. Of course, there is also no run-time check. Therefore, assert should be used only to verify things that truly should not be possible. It can be useful as an aid in getting a program debugged but should not be used to substitute for runtime logic checks or error checking that the program should do.

//In addition to using assert, we can write our own conditional debugging code using NDEBUG. If NDEBUG is not defined, the code between the #ifndef and the #endif is executed. If NDEBUG is defined, that code is ignored:
void print(const int ia[], size_t size){
    #ifndef NDEBUG
    // _ _func_ _ is a local static defined by the compiler that holds the function's name
    cerr << _ _func_ _ << ": array size is " << size << endl;
    #endif
    // ...
//Here we use a variable named _ _func_ _ to print the name of the function we are debugging. The compiler defines _ _func_ _ in every function. It is a local static array of const char that holds the name of the function.
//In addition to __func__, which the C++ compiler defines, the preprocessor defines four other names that can be useful in debugging:
//__FILE__ string literal containing the name of the file
//__LINE__ integer literal containing the current line number
//__TIME__ string literal containing the time the file was compiled
//__DATE__ string literal containing the date the file was compiled

//6.6 Function Matching

//Determining the Candidate and Viable Functions

void f();
void f(int);
void f(int, int);
void f(double, double = 3.14);
f(5.6); // calls void f(double, double)
//The first step of function matching identifies the set of overloaded functions considered for the call. The functions in this set are the candidate functions. A candidate function is a function with the same name as the called function and for which a declaration is visible at the point of the call. In this example, there are four candidate functions named f.
//The second step selects from the set of candidate functions those functions that can be called with the arguments in the given call. The selected functions are the viable functions. To be viable, a function must have the same number of parameters as there are arguments in the call, and the type of each argument must match—or be convertible to—the type of its corresponding parameter.
//We can eliminate two of our candidate functions based on the number of arguments. The function that has no parameters and the one that has two int parameters are not viable for this call. Our call has only one argument, and these functions have zero and two parameters, respectively.
//The function that takes a single int and the function that takes two doubles might be viable. Either of these functions can be called with a single argument. The function taking two doubles has a default argument, which means it can be called with a single argument.
//Having used the number of arguments to winnow the candidate functions, we next look at whether the argument types match those of the parameters. As with any call, an argument might match its parameter either because the types match exactly or because there is a conversion from the argument type to the type of the parameter.
//In this example, both of our remaining functions are viable:
//f(int) is viable because a conversion exists that can convert the argument of type double to the parameter of type int.
//f(double, double) is viable because a default argument is provided for the function’s second parameter and its first parameter is of type double, which exactly matches the type of the parameter.

//When a function has default arguments, a call may appear to have fewer arguments than it actually does.
//If there are no viable functions, the compiler will complain that there is no matching function.

//The third step of function matching determines which viable function provides the best match for the call. This process looks at each argument in the call and selects the viable function (or functions) for which the corresponding parameter best matches the argument. We’ll explain the details of “best” in the next section, but the idea is that the closer the types of the argument and parameter are to each other, the better the match.
//In our case, there is only one (explicit) argument in the call. That argument has type double. To call f(int), the argument would have to be converted from double to int. The other viable function, f(double, double), is an exact match for this argument. An exact match is better than a match that requires a conversion. Therefore, the compiler will resolve the call f(5.6) as a call to the function that has two double parameters. The compiler will add the default argument for the second, missing argument.

//Function Matching with Multiple Parameters
//There is an overall best match if there is one and only one function for which:
//The match for each argument is no worse than the match required by any other viable functions; there is at least one argument for which the match is better than the match provided by any other viable function.
//If after looking at each argument there is no single function that is preferable, then the call is in error. The compiler will complain that the call is ambiguous.

//Casts should not be needed to call an overloaded function. The need for a cast suggests that the parameter sets are designed poorly.

//6.6.1 Argument Type Conversions

//In order to determine the best match, the compiler ranks the conversions that could be used convert each argument to the type of its corresponding parameter.
//Conversions are ranked as follows:
//1. An exact match. An exact match happens when:
//The argument and parameter types are identical;
//The argument is converted from an array or function type to corresponding pointer type;
//A top-level const is added to or discarded from the argument.
//2. Match through a const conversion.
//3. Match through a promotion.
//4. Match through an arithmetic or pointer conversion.
//5. Match through a class-type conversion.

//Promotions and conversions among the built-in types can yield surprising results in the context of function matching. Fortunately, well-designed systems rarely include functions with parameters as closely related as those in the following examples.

//Matches Requiring Promotion or Arithmetic Conversion
//In order to analyze a call, it is important to remember that the small integral types always promote to int or to a larger integral type. Given two functions, one of which takes an int and the other a short, the short version will be called only on values of type short. Even though the smaller integral values might appear to be a closer match, those values are promoted to int, whereas calling the short version would require a conversion.

//All the arithmetic conversions are treated as equivalent to each other. The conversion from int to unsigned int, for example, does not take precedence over the conversion from int to double.

//Function Matching and const Arguments

//When we call an overloaded function that differs on whether a reference of pointer parameter refers or points to const, the compiler uses the constness of the argument to decide which function to call.

//6.7 Pointers to Functions

//A function pointer is just that - a pointer that denotes a function rather than an object. Like any other pointer, a function pointer points to a particular type. A function's type is determined by its return type and the types of its parameters. The function's name is not part of its type.
bool lengthCompare(const string &, const string &);
//has type bool(const string&, const string&). To declare a pointer that can point at this function, we declare a pointer in place of the function name:
//pf points to a function returning bool that takes two const string references
bool (*pf) (const string&, const string&);    //uninitialized
//Starting from the name we are declaring, we see that pf is preceded by a *, so pf is a pointer. To the right is a parameter list, which means that pf points a function. Looking left, we find that the type the function returns is bool. Thus, pf points to a function that has two const string& parameters and returns a bool.
//Note: The parameters around *pf are necessary. If we omit the parentheses, then we declare pf as a function that returns a pointer to bool:
//declare a function named pf that returns a bool*
bool *pf(const string&, const string&);

//Using Function Pointers
//When we use the name of a function as a value, the function is automatically converted to a pointer. For example, we can assign the address of lengthCompare to pf as follows:
pf=lengthCompare;  //pf now points to the function named lengthCompare
pf=&lengthCompare;  //equivalent assignment: address-of operator is optional

//Moreover, we can use a pointer to a function to call the function to which the pointer points. We can do so directly - there is no need to dereference the pointer:
bool b1=pf("hello", "goodbye");    //calls lengthCompare
bool b2=(*pf)("hello", "goodbye");    //equivalent call
bool b3=lengthCompare("hello", "goodbye");    //equivalent call

//There is no conversion between pointers to one function type and pointers to another function type. However, as usual, we can assign nullptr or a zero-valued integer constant expression to a function pointer to indicate that the pointer does not point to any function:
string::size_type sumLength(const string&, const string&);
bool cstringCompare(const char*, const char*);
pf = 0; // ok: pf points to no function
pf = sumLength; // error: return type differs
pf = cstringCompare; // error: parameter types differ
pf = lengthCompare; // ok: function and pointer types match exactly

//Pointers to Overloaded Functions
//As usual, when we use an overloaded function, the context must make it clear which version is being used. When we declare a pointer to an overloaded function
void ff(int*);
void ff(unsigned int);
void (*pf1)(unsigned int) = ff; // pf1 points to ff(unsigned)
//the compiler uses the type of the pointer to determine which overloaded function to use. The type of the pointer must match one of the overloaded functions exactly:
void (*pf2)(int) = ff; // error: no ff with a matching parameter list
double (*pf3)(int*) = ff; // error: return type of ff and pf3 don't match

//Function Pointer Parameters
//Just as with arrays, we cannot define parameters of function type but can have a parameter that is a pointer to function. As with arrays, we can write a parameter that looks like a function type, but it will be treated as a pointer:
// third parameter is a function type and is automatically treated as a pointer to function
void useBigger(const string &s1, const string &s2,
bool pf(const string &, const string &));
// equivalent declaration: explicitly define the parameter as a pointer to function
void useBigger(const string &s1, const string &s2,
bool (*pf)(const string &, const string &));
//When we pass a function as an argument, we can do so directly. It will be automatically converted to a pointer:
// automatically converts the function lengthCompare to a pointer to function
useBigger(s1, s2, lengthCompare);
//As we’ve just seen in the declaration of useBigger, writing function pointer types quickly gets tedious. Type aliases, along with decltype, let us simplify code that uses function pointers:
// Func and Func2 have function type
typedef bool Func(const string&, const string&);
typedef decltype(lengthCompare) Func2; // equivalent type
// FuncP and FuncP2 have pointer to function type
typedef bool(*FuncP)(const string&, const string&);
typedef decltype(lengthCompare) *FuncP2; // equivalent type
//Here we’ve used typedef to define our types. Both Func and Func2 are function types, whereas FuncP and FuncP2 are pointer types. It is important to note that decltype returns the function type; the automatic conversion to pointer is not done. Because decltype returns a function type, if we want a pointer we must add the * ourselves. We can redeclare useBigger using any of these types:
// equivalent declarations of useBigger using type aliases
void useBigger(const string&, const string&, Func);
void useBigger(const string&, const string&, FuncP2);
//Both declarations declare the same function. In the first case, the compiler will automatically convert the function type represented by Func to a pointer.

//Returning a Pointer to Function
//As with arrays, we can’t return a function type but can return a pointer to a function type. Similarly, we must write the return type as a pointer type; the compiler will not automatically treat a function return type as the corresponding pointer type. Also as with array returns, by far the easiest way to declare a function that returns a pointer to function is by using a type alias:
using F = int(int*, int); // F is a function type, not a pointer
using PF = int(*)(int*, int); // PF is a pointer type
//Here we used type alias declarations to define F as a function type and PF as a pointer to function type. The thing to keep in mind is that, unlike what happens to parameters that have function type, the return type is not automatically converted to a pointer type. We must explicitly specify that the return type is a pointer type:
PF f1(int); // ok: PF is a pointer to function; f1 returns a pointer to function
F f1(int); // error: F is a function type; f1 can't return a function
F *f1(int); // ok: explicitly specify that the return type is a pointer to function
//Of course, we can also declare f1 directly, which we’d do as
int (*f1(int))(int*, int);
//Reading this declaration from the inside out, we see that f1 has a parameter list, so f1 is a function. f1 is preceded by a * so f1 returns a pointer. The type of that pointer itself has a parameter list, so the pointer points to a function. That function returns an int.
//For completeness, it’s worth noting that we can simplify declarations of functions that return pointers to function by using a trailing return:
auto f1(int)->int(*) (int*, int);

//Using auto or decltype for Function Pointer Types
//If we know which function(s) we want to return, we can use decltype to simplify writing a function pointer return type. For example, assume we have two functions, both of which return a string::size_type and have two const string& parameters. We can write a third function that takes a string parameter and returns a pointer to one of these two functions as follows:
string::size_type sumLength(const string&, const string&);
string::size_type largerLength(const string&, const string&);
// depending on the value of its string parameter,
// getFcn returns a pointer to sumLength or to largerLength
decltype(sumLength) *getFcn(const string &);
//The only tricky part in declaring getFcn is to remember that when we apply decltype to a function, it returns a function type, not a pointer to function type. We must add a * to indicate that we are returning a pointer, not a function.
